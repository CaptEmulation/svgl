#ifndef __svg_SVGSVGElement__
#define __svg_SVGSVGElement__

// generated by genFromIdl.py
	class xmlostream;
	class DOM_Node;

namespace svg {
	class NodeList;
	class SVGRect;
	class SVGElement;
	class SVGNumber;
	class SVGLength;
	class SVGAngle;
	class SVGPoint;
	class SVGMatrix;
	class SVGTransform;
	class SVGSVGElement;
}

namespace svgl {
	class AnimateAdapter;
	class Context;
	class GLInfo;
}

#include <w3c/svg/SVGElement.hpp>
#include <w3c/svg/SVGTests.hpp>
#include <w3c/svg/SVGLangSpace.hpp>
#include <w3c/svg/SVGExternalResourcesRequired.hpp>
#include <w3c/svg/SVGStylable.hpp>
#include <w3c/svg/SVGLocatable.hpp>
#include <w3c/svg/SVGFitToViewBox.hpp>
#include <w3c/svg/SVGZoomAndPan.hpp>
#include <w3c/events/EventTarget.hpp>
#include <w3c/events/DocumentEvent.hpp>
#include <w3c/css/ViewCSS.hpp>
#include <w3c/css/DocumentCSS.hpp>
#include <w3c/svg/Attribute.hpp>
#include <w3c/svg/SVGAnimatedLength.hpp>
#include <w3c/svg/DOMString.hpp>
#include <w3c/svg/SVGRect.hpp>
#include <w3c/svg/SVGViewSpec.hpp>
#include <w3c/svg/SVGPoint.hpp>
#include <w3c/svg/DOMString.hpp>
#include <w3c/svg/DOMString.hpp>
#include <w3c/svg/String.hpp>
#include <map>

namespace svg {
            extern unicode::String * SVGSVGElement_element_string;
}

namespace svg {
	class SVGSVGElement :
		public SVGElement,
		public SVGTests,
		public SVGLangSpace,
		public SVGExternalResourcesRequired,
		public SVGStylable,
		public SVGLocatable,
		public SVGFitToViewBox,
		public SVGZoomAndPan,
		public events::EventTarget,
		public events::DocumentEvent,
		public css::ViewCSS,
		public css::DocumentCSS {
	public:
	protected:
		Attribute< SVGAnimatedLength > x;
		Attribute< SVGAnimatedLength > y;
		Attribute< SVGAnimatedLength > width;
		Attribute< SVGAnimatedLength > height;
		Attribute< DOMString > contentScriptType;
		Attribute< DOMString > contentStyleType;
		Attribute< SVGRect > viewport;
		Attribute< float > pixelUnitToMillimeterX;
		Attribute< float > pixelUnitToMillimeterY;
		Attribute< float > screenPixelToMillimeterX;
		Attribute< float > screenPixelToMillimeterY;
		Attribute< bool > useCurrentView;
		Attribute< SVGViewSpec > currentView;
		Attribute< float > currentScale;
		Attribute< SVGPoint > currentTranslate;
	public:
		const Attribute< SVGAnimatedLength >& dom_getX() const { return x; }

		const Attribute< SVGAnimatedLength >& dom_getY() const { return y; }

		const Attribute< SVGAnimatedLength >& dom_getWidth() const { return width; }

		const Attribute< SVGAnimatedLength >& dom_getHeight() const { return height; }

		const Attribute< DOMString >& dom_getContentScriptType() const { return contentScriptType; }
		Attribute< DOMString >& dom_getContentScriptType() { return contentScriptType; }
		void dom_setContentScriptType(const DOMString& n)  { contentScriptType.setValue(n); }

		const Attribute< DOMString >& dom_getContentStyleType() const { return contentStyleType; }
		Attribute< DOMString >& dom_getContentStyleType() { return contentStyleType; }
		void dom_setContentStyleType(const DOMString& n)  { contentStyleType.setValue(n); }

		const Attribute< SVGRect >& dom_getViewport() const { return viewport; }

		const Attribute< float >& dom_getPixelUnitToMillimeterX() const { return pixelUnitToMillimeterX; }

		const Attribute< float >& dom_getPixelUnitToMillimeterY() const { return pixelUnitToMillimeterY; }

		const Attribute< float >& dom_getScreenPixelToMillimeterX() const { return screenPixelToMillimeterX; }

		const Attribute< float >& dom_getScreenPixelToMillimeterY() const { return screenPixelToMillimeterY; }

		const Attribute< bool >& dom_getUseCurrentView() const { return useCurrentView; }
		Attribute< bool >& dom_getUseCurrentView() { return useCurrentView; }
		void dom_setUseCurrentView(const bool& n)  { useCurrentView.setValue(n); }

		const Attribute< SVGViewSpec >& dom_getCurrentView() const { return currentView; }

		const Attribute< float >& dom_getCurrentScale() const { return currentScale; }
		Attribute< float >& dom_getCurrentScale() { return currentScale; }
		void dom_setCurrentScale(const float& n)  { currentScale.setValue(n); }

		const Attribute< SVGPoint >& dom_getCurrentTranslate() const { return currentTranslate; }

	public:
		const SVGLength & getX() const { return x.getValue().getAnimatedVal().getValue(); }
		void setX(const SVGLength& n)  { x.getValue().getAnimatedVal().setValue(n); x.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const SVGLength & getY() const { return y.getValue().getAnimatedVal().getValue(); }
		void setY(const SVGLength& n)  { y.getValue().getAnimatedVal().setValue(n); y.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const SVGLength & getWidth() const { return width.getValue().getAnimatedVal().getValue(); }
		void setWidth(const SVGLength& n)  { width.getValue().getAnimatedVal().setValue(n); width.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const SVGLength & getHeight() const { return height.getValue().getAnimatedVal().getValue(); }
		void setHeight(const SVGLength& n)  { height.getValue().getAnimatedVal().setValue(n); height.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const DOMString & getContentScriptType() const { return contentScriptType.getValue(); }
		DOMString & getContentScriptType() { return contentScriptType.getValue(); }
		void setContentScriptType(const DOMString& n)  { contentScriptType.setValue(n);  setDamaged(true); }

		const DOMString & getContentStyleType() const { return contentStyleType.getValue(); }
		DOMString & getContentStyleType() { return contentStyleType.getValue(); }
		void setContentStyleType(const DOMString& n)  { contentStyleType.setValue(n);  setDamaged(true); }

		const SVGRect & getViewport() const { return viewport.getValue(); }
		void setViewport(const SVGRect& n)  { viewport.setValue(n);  setDamaged(true); }

		const float & getPixelUnitToMillimeterX() const { return pixelUnitToMillimeterX.getValue(); }
		void setPixelUnitToMillimeterX(const float& n)  { pixelUnitToMillimeterX.setValue(n);  setDamaged(true); }

		const float & getPixelUnitToMillimeterY() const { return pixelUnitToMillimeterY.getValue(); }
		void setPixelUnitToMillimeterY(const float& n)  { pixelUnitToMillimeterY.setValue(n);  setDamaged(true); }

		const float & getScreenPixelToMillimeterX() const { return screenPixelToMillimeterX.getValue(); }
		void setScreenPixelToMillimeterX(const float& n)  { screenPixelToMillimeterX.setValue(n);  setDamaged(true); }

		const float & getScreenPixelToMillimeterY() const { return screenPixelToMillimeterY.getValue(); }
		void setScreenPixelToMillimeterY(const float& n)  { screenPixelToMillimeterY.setValue(n);  setDamaged(true); }

		const bool & getUseCurrentView() const { return useCurrentView.getValue(); }
		bool & getUseCurrentView() { return useCurrentView.getValue(); }
		void setUseCurrentView(const bool& n)  { useCurrentView.setValue(n);  setDamaged(true); }

		const SVGViewSpec & getCurrentView() const { return currentView.getValue(); }
		void setCurrentView(const SVGViewSpec& n)  { currentView.setValue(n);  setDamaged(true); }

		const float & getCurrentScale() const { return currentScale.getValue(); }
		float & getCurrentScale() { return currentScale.getValue(); }
		void setCurrentScale(const float& n)  { currentScale.setValue(n);  setDamaged(true); }

		const SVGPoint & getCurrentTranslate() const { return currentTranslate.getValue(); }
		void setCurrentTranslate(const SVGPoint& n)  { currentTranslate.setValue(n);  setDamaged(true); }


	private:
		typedef std::map<DOMString, SVGElement*> ElementByIDContainer;
		ElementByIDContainer _elements_by_id;

	public:
		void setElementById(const DOMString& id, SVGElement* e);
		void setOwnerAndViewPort(SVGSVGElement* owner, SVGElement* viewport);
		void glTraverseFromUse(svgl::Context*, svgl::GLInfo* glinfo, float width, float height);
		void pickTraverseFromUse(svgl::Context*, svgl::GLInfo* glinfo, float width, float height);

		virtual void glTraverse(svgl::Context*, svgl::GLInfo*)  ;

		virtual void glTraverseBranch(svgl::Context*, svgl::GLInfo*, Branch::iterator& beg, Branch::iterator& end)   ;

		virtual void pickTraverse(svgl::Context*, svgl::GLInfo*)  ;
	public:
		virtual unsigned long suspendRedraw ( unsigned long max_wait_milliseconds ) ;
		virtual void unsuspendRedraw ( unsigned long suspend_handle_id ) ;
		virtual void unsuspendRedrawAll (  ) ;
		virtual void forceRedraw (  ) ;
		virtual void pauseAnimations (  ) ;
		virtual void unpauseAnimations (  ) ;
		virtual bool animationsPaused (  ) ;
		virtual float getCurrentTime (  ) ;
		virtual void setCurrentTime ( float seconds ) ;
		virtual NodeList* getIntersectionList ( const SVGRect& rect, const SVGElement& referenceElement ) ;
		virtual NodeList* getEnclosureList ( const SVGRect& rect, const SVGElement& referenceElement ) ;
		virtual bool checkIntersection ( const SVGElement& element, const SVGRect& rect ) ;
		virtual bool checkEnclosure ( const SVGElement& element, const SVGRect& rect ) ;
		virtual void deSelectAll (  ) ;
		virtual SVGNumber* createSVGNumber (  ) ;
		virtual SVGLength* createSVGLength (  ) ;
		virtual SVGAngle* createSVGAngle (  ) ;
		virtual SVGPoint* createSVGPoint (  ) ;
		virtual SVGMatrix* createSVGMatrix (  ) ;
		virtual SVGRect* createSVGRect (  ) ;
		virtual SVGTransform* createSVGTransform (  ) ;
		virtual SVGTransform* createSVGTransformFromMatrix ( const SVGMatrix& matrix ) ;
		virtual DOMString* createSVGString (  ) ;
		virtual Element* getElementById ( const DOMString& elementId ) ;
		virtual int parse_attributes(const String&, const String&);
		virtual void print_attributes(xmlostream&);
	public:
		virtual svgl::AnimateAdapter* getAttributeByName(const String&);

	public:
		virtual ~SVGSVGElement();
		virtual const String getDtdElement() const { return SVGSVGElement_element_string; }
		SVGSVGElement(dom::Document* doc) : SVGElement(doc, SVGSVGElement_element_string) {}
	};
}


#endif // __svg_SVGSVGElement__
