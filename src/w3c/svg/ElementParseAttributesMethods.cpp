// generated by makeParseAttribute.py

//#include <w3c/svg/makeEnumType.hpp>
#include <svgl/parseHelper.hpp>
//#include <w3c/dom/DOM.hpp>
#include <w3c/svg/String.hpp>
#include <w3c/svg/String.hpp>
#include <w3c/svg/SVGAElement.hpp>
#include <w3c/svg/SVGElement.hpp>
#include <w3c/svg/SVGURIReference.hpp>
#include <w3c/svg/SVGTests.hpp>
#include <w3c/svg/SVGLangSpace.hpp>
#include <w3c/svg/SVGExternalResourcesRequired.hpp>
#include <w3c/svg/SVGStylable.hpp>
#include <w3c/svg/SVGTransformable.hpp>
#include <w3c/svg/SVGAltGlyphDefElement.hpp>
#include <w3c/svg/SVGAltGlyphElement.hpp>
#include <w3c/svg/SVGTextPositioningElement.hpp>
#include <w3c/svg/SVGTextContentElement.hpp>
#include <w3c/svg/SVGAltGlyphItemElement.hpp>
#include <w3c/svg/SVGAnimateColorElement.hpp>
#include <w3c/svg/SVGAnimationElement.hpp>
#include <w3c/svg/SVGAnimateElement.hpp>
#include <w3c/svg/SVGAnimateMotionElement.hpp>
#include <w3c/svg/SVGAnimateTransformElement.hpp>
#include <w3c/svg/SVGAnimatedPathData.hpp>
#include <w3c/svg/SVGAnimatedPoints.hpp>
#include <w3c/svg/SVGCircleElement.hpp>
#include <w3c/svg/SVGClipPathElement.hpp>
#include <w3c/svg/SVGColorProfileElement.hpp>
#include <w3c/svg/SVGComponentTransferFunctionElement.hpp>
#include <w3c/svg/SVGCursorElement.hpp>
#include <w3c/svg/SVGDefinitionSrcElement.hpp>
#include <w3c/svg/SVGDefsElement.hpp>
#include <w3c/svg/SVGDescElement.hpp>
#include <w3c/svg/SVGEllipseElement.hpp>
#include <w3c/svg/SVGFEBlendElement.hpp>
#include <w3c/svg/SVGFilterPrimitiveStandardAttributes.hpp>
#include <w3c/svg/SVGFEColorMatrixElement.hpp>
#include <w3c/svg/SVGFEComponentTransferElement.hpp>
#include <w3c/svg/SVGFECompositeElement.hpp>
#include <w3c/svg/SVGFEConvolveMatrixElement.hpp>
#include <w3c/svg/SVGFEDiffuseLightingElement.hpp>
#include <w3c/svg/SVGFEDisplacementMapElement.hpp>
#include <w3c/svg/SVGFEDistantLightElement.hpp>
#include <w3c/svg/SVGFEFloodElement.hpp>
#include <w3c/svg/SVGFEFuncAElement.hpp>
#include <w3c/svg/SVGFEFuncBElement.hpp>
#include <w3c/svg/SVGFEFuncGElement.hpp>
#include <w3c/svg/SVGFEFuncRElement.hpp>
#include <w3c/svg/SVGFEGaussianBlurElement.hpp>
#include <w3c/svg/SVGFEImageElement.hpp>
#include <w3c/svg/SVGFEMergeElement.hpp>
#include <w3c/svg/SVGFEMergeNodeElement.hpp>
#include <w3c/svg/SVGFEMorphologyElement.hpp>
#include <w3c/svg/SVGFEOffsetElement.hpp>
#include <w3c/svg/SVGFEPointLightElement.hpp>
#include <w3c/svg/SVGFESpecularLightingElement.hpp>
#include <w3c/svg/SVGFESpotLightElement.hpp>
#include <w3c/svg/SVGFETileElement.hpp>
#include <w3c/svg/SVGFETurbulenceElement.hpp>
#include <w3c/svg/SVGFilterElement.hpp>
#include <w3c/svg/SVGFitToViewBox.hpp>
#include <w3c/svg/SVGFontElement.hpp>
#include <w3c/svg/SVGFontFaceElement.hpp>
#include <w3c/svg/SVGFontFaceFormatElement.hpp>
#include <w3c/svg/SVGFontFaceNameElement.hpp>
#include <w3c/svg/SVGFontFaceSrcElement.hpp>
#include <w3c/svg/SVGFontFaceUriElement.hpp>
#include <w3c/svg/SVGForeignObjectElement.hpp>
#include <w3c/svg/SVGGElement.hpp>
#include <w3c/svg/SVGGlyphElement.hpp>
#include <w3c/svg/SVGGlyphRefElement.hpp>
#include <w3c/svg/SVGGradientElement.hpp>
#include <w3c/svg/SVGHKernElement.hpp>
#include <w3c/svg/SVGImageElement.hpp>
#include <w3c/svg/SVGLineElement.hpp>
#include <w3c/svg/SVGLinearGradientElement.hpp>
#include <w3c/svg/SVGMPathElement.hpp>
#include <w3c/svg/SVGMarkerElement.hpp>
#include <w3c/svg/SVGMaskElement.hpp>
#include <w3c/svg/SVGMetadataElement.hpp>
#include <w3c/svg/SVGMissingGlyphElement.hpp>
#include <w3c/svg/SVGPathElement.hpp>
#include <w3c/svg/SVGPatternElement.hpp>
#include <w3c/svg/SVGPolygonElement.hpp>
#include <w3c/svg/SVGPolylineElement.hpp>
#include <w3c/svg/SVGRadialGradientElement.hpp>
#include <w3c/svg/SVGRectElement.hpp>
#include <w3c/svg/SVGSVGElement.hpp>
#include <w3c/svg/SVGZoomAndPan.hpp>
#include <w3c/svg/SVGScriptElement.hpp>
#include <w3c/svg/SVGSetElement.hpp>
#include <w3c/svg/SVGStopElement.hpp>
#include <w3c/svg/SVGStyleElement.hpp>
#include <w3c/svg/SVGSwitchElement.hpp>
#include <w3c/svg/SVGSymbolElement.hpp>
#include <w3c/svg/SVGTRefElement.hpp>
#include <w3c/svg/SVGTSpanElement.hpp>
#include <w3c/svg/SVGTextElement.hpp>
#include <w3c/svg/SVGTextPathElement.hpp>
#include <w3c/svg/SVGTitleElement.hpp>
#include <w3c/svg/SVGUseElement.hpp>
#include <w3c/svg/SVGVKernElement.hpp>
#include <w3c/svg/SVGViewElement.hpp>
#include <w3c/svg/SVGViewSpec.hpp>


namespace svg {

// SVGAnimateMotionElement
    
int
SVGAnimateMotionElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimateMotionElement::parse" << std::endl;
  {

    if (*attrName==*values_attribute_string) {
      *attrValue >> values;
      ++recognized;
    } else

    if (*attrName==*path_attribute_string) {
      *attrValue >> path;
      ++recognized;
    } else

    if (*attrName==*rotate_attribute_string) {
      *attrValue >> rotate;
      ++recognized;
    } else

    if (SVGAnimationElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAnimateMotionElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFontFaceUriElement
    
int
SVGFontFaceUriElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFontFaceUriElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFontFaceUriElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFontFaceElement
    
int
SVGFontFaceElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFontFaceElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFontFaceElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEFuncBElement
    
int
SVGFEFuncBElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEFuncBElement::parse" << std::endl;
  {

    if (SVGComponentTransferFunctionElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEFuncBElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEFuncAElement
    
int
SVGFEFuncAElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEFuncAElement::parse" << std::endl;
  {

    if (SVGComponentTransferFunctionElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEFuncAElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEFuncRElement
    
int
SVGFEFuncRElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEFuncRElement::parse" << std::endl;
  {

    if (SVGComponentTransferFunctionElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEFuncRElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGForeignObjectElement
    
int
SVGForeignObjectElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGForeignObjectElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGForeignObjectElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEMorphologyElement
    
int
SVGFEMorphologyElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEMorphologyElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*operator_attribute_string) {
      *attrValue >> operator_;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEMorphologyElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGMarkerElement
    
int
SVGMarkerElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGMarkerElement::parse" << std::endl;
  {

    if (*attrName==*refX_attribute_string) {
      *attrValue >> refX;
      ++recognized;
    } else

    if (*attrName==*refY_attribute_string) {
      *attrValue >> refY;
      ++recognized;
    } else

    if (*attrName==*markerUnits_attribute_string) {
      *attrValue >> markerUnits;
      ++recognized;
    } else

    if (*attrName==*markerWidth_attribute_string) {
      *attrValue >> markerWidth;
      ++recognized;
    } else

    if (*attrName==*markerHeight_attribute_string) {
      *attrValue >> markerHeight;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFitToViewBox::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (customParseAttributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGMarkerElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFETileElement
    
int
SVGFETileElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFETileElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFETileElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGPathElement
    
int
SVGPathElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGPathElement::parse" << std::endl;
  {

    if (*attrName==*pathLength_attribute_string) {
      *attrValue >> pathLength;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGAnimatedPathData::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGPathElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTSpanElement
    
int
SVGTSpanElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTSpanElement::parse" << std::endl;
  {

    if (SVGTextPositioningElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGTSpanElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEColorMatrixElement
    
int
SVGFEColorMatrixElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEColorMatrixElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*type_attribute_string) {
      *attrValue >> type;
      ++recognized;
    } else

    if (*attrName==*values_attribute_string) {
      *attrValue >> values;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEColorMatrixElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFontFaceFormatElement
    
int
SVGFontFaceFormatElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFontFaceFormatElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFontFaceFormatElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEOffsetElement
    
int
SVGFEOffsetElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEOffsetElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*dx_attribute_string) {
      *attrValue >> dx;
      ++recognized;
    } else

    if (*attrName==*dy_attribute_string) {
      *attrValue >> dy;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEOffsetElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGSymbolElement
    
int
SVGSymbolElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGSymbolElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFitToViewBox::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGSymbolElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEMergeNodeElement
    
int
SVGFEMergeNodeElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEMergeNodeElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEMergeNodeElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTransformable
    
int
SVGTransformable::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTransformable::parse" << std::endl;
  {

    if (*attrName==*transform_attribute_string) {
      *attrValue >> transform;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGStyleElement
    
int
SVGStyleElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGStyleElement::parse" << std::endl;
  {

    if (*attrName==*xml_space_attribute_string) {
      *attrValue >> xmlspace;
      ++recognized;
    } else

    if (*attrName==*type_attribute_string) {
      *attrValue >> type;
      ++recognized;
    } else

    if (*attrName==*media_attribute_string) {
      *attrValue >> media;
      ++recognized;
    } else

    if (*attrName==*title_attribute_string) {
      *attrValue >> title;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGStyleElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGPolygonElement
    
int
SVGPolygonElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGPolygonElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGAnimatedPoints::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGPolygonElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGCursorElement
    
int
SVGCursorElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGCursorElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGCursorElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFECompositeElement
    
int
SVGFECompositeElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFECompositeElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*in2_attribute_string) {
      *attrValue >> in2;
      ++recognized;
    } else

    if (*attrName==*operator_attribute_string) {
      *attrValue >> operator_;
      ++recognized;
    } else

    if (*attrName==*k1_attribute_string) {
      *attrValue >> k1;
      ++recognized;
    } else

    if (*attrName==*k2_attribute_string) {
      *attrValue >> k2;
      ++recognized;
    } else

    if (*attrName==*k3_attribute_string) {
      *attrValue >> k3;
      ++recognized;
    } else

    if (*attrName==*k4_attribute_string) {
      *attrValue >> k4;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFECompositeElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGGradientElement
    
int
SVGGradientElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGGradientElement::parse" << std::endl;
  {

    if (*attrName==*gradientUnits_attribute_string) {
      *attrValue >> gradientUnits;
      ++recognized;
    } else

    if (*attrName==*gradientTransform_attribute_string) {
      *attrValue >> gradientTransform;
      ++recognized;
    } else

    if (*attrName==*spreadMethod_attribute_string) {
      *attrValue >> spreadMethod;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGLinearGradientElement
    
int
SVGLinearGradientElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGLinearGradientElement::parse" << std::endl;
  {

    if (*attrName==*x1_attribute_string) {
      *attrValue >> x1;
      ++recognized;
    } else

    if (*attrName==*y1_attribute_string) {
      *attrValue >> y1;
      ++recognized;
    } else

    if (*attrName==*x2_attribute_string) {
      *attrValue >> x2;
      ++recognized;
    } else

    if (*attrName==*y2_attribute_string) {
      *attrValue >> y2;
      ++recognized;
    } else

    if (SVGGradientElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGLinearGradientElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTextElement
    
int
SVGTextElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTextElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (SVGTextContentElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGTextElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEPointLightElement
    
int
SVGFEPointLightElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEPointLightElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*z_attribute_string) {
      *attrValue >> z;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEPointLightElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGHKernElement
    
int
SVGHKernElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGHKernElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGHKernElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGStopElement
    
int
SVGStopElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGStopElement::parse" << std::endl;
  {

    if (*attrName==*offset_attribute_string) {
      *attrValue >> offset;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGStopElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEDisplacementMapElement
    
int
SVGFEDisplacementMapElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEDisplacementMapElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*in2_attribute_string) {
      *attrValue >> in2;
      ++recognized;
    } else

    if (*attrName==*scale_attribute_string) {
      *attrValue >> scale;
      ++recognized;
    } else

    if (*attrName==*xChannelSelector_attribute_string) {
      *attrValue >> xChannelSelector;
      ++recognized;
    } else

    if (*attrName==*yChannelSelector_attribute_string) {
      *attrValue >> yChannelSelector;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEDisplacementMapElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGLineElement
    
int
SVGLineElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGLineElement::parse" << std::endl;
  {

    if (*attrName==*x1_attribute_string) {
      *attrValue >> x1;
      ++recognized;
    } else

    if (*attrName==*y1_attribute_string) {
      *attrValue >> y1;
      ++recognized;
    } else

    if (*attrName==*x2_attribute_string) {
      *attrValue >> x2;
      ++recognized;
    } else

    if (*attrName==*y2_attribute_string) {
      *attrValue >> y2;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGLineElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFontFaceNameElement
    
int
SVGFontFaceNameElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFontFaceNameElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFontFaceNameElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGPatternElement
    
int
SVGPatternElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGPatternElement::parse" << std::endl;
  {

    if (*attrName==*patternUnits_attribute_string) {
      *attrValue >> patternUnits;
      ++recognized;
    } else

    if (*attrName==*patternTransform_attribute_string) {
      *attrValue >> patternTransform;
      ++recognized;
    } else

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFitToViewBox::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGPatternElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGExternalResourcesRequired
    
int
SVGExternalResourcesRequired::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGExternalResourcesRequired::parse" << std::endl;
  {

    if (*attrName==*externalResourcesRequired_attribute_string) {
      *attrValue >> externalResourcesRequired;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGScriptElement
    
int
SVGScriptElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGScriptElement::parse" << std::endl;
  {

    if (*attrName==*type_attribute_string) {
      *attrValue >> type;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGScriptElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGStylable
    
int
SVGStylable::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGStylable::parse" << std::endl;
  {

    if (*attrName==*class_attribute_string) {
      *attrValue >> className;
      ++recognized;
    } else

    if (*attrName==*style_attribute_string) {
      *attrValue >> style;
      ++recognized;
    } else

    if (customParseAttributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGFitToViewBox
    
int
SVGFitToViewBox::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFitToViewBox::parse" << std::endl;
  {

    if (*attrName==*viewBox_attribute_string) {
      *attrValue >> viewBox;
      ++recognized;
    } else

    if (*attrName==*preserveAspectRatio_attribute_string) {
      *attrValue >> preserveAspectRatio;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGTests
    
int
SVGTests::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTests::parse" << std::endl;
  {

    if (*attrName==*requiredFeatures_attribute_string) {
      *attrValue >> requiredFeatures;
      ++recognized;
    } else

    if (*attrName==*requiredExtensions_attribute_string) {
      *attrValue >> requiredExtensions;
      ++recognized;
    } else

    if (*attrName==*systemLanguage_attribute_string) {
      *attrValue >> systemLanguage;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGSVGElement
    
int
SVGSVGElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGSVGElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (*attrName==*contentScriptType_attribute_string) {
      *attrValue >> contentScriptType;
      ++recognized;
    } else

    if (*attrName==*contentStyleType_attribute_string) {
      *attrValue >> contentStyleType;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFitToViewBox::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGZoomAndPan::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGSVGElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGViewSpec
    
int
SVGViewSpec::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGViewSpec::parse" << std::endl;
  {

    if (SVGZoomAndPan::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFitToViewBox::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGVKernElement
    
int
SVGVKernElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGVKernElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGVKernElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGMetadataElement
    
int
SVGMetadataElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGMetadataElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGMetadataElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAElement
    
int
SVGAElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAElement::parse" << std::endl;
  {

    if (*attrName==*target_attribute_string) {
      *attrValue >> target;
      ++recognized;
    } else

    if (*attrName==*xlink_show_attribute_string) {
      *attrValue >> xlinkShow;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAltGlyphElement
    
int
SVGAltGlyphElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAltGlyphElement::parse" << std::endl;
  {

    if (*attrName==*glyphRef_attribute_string) {
      *attrValue >> glyphRef;
      ++recognized;
    } else

    if (*attrName==*format_attribute_string) {
      *attrValue >> format;
      ++recognized;
    } else

    if (SVGTextPositioningElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAltGlyphElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGURIReference
    
int
SVGURIReference::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGURIReference::parse" << std::endl;
  {

    if (*attrName==*xlink_type_attribute_string) {
      *attrValue >> xlinkType;
      ++recognized;
    } else

    if (*attrName==*xlink_role_attribute_string) {
      *attrValue >> xlinkRole;
      ++recognized;
    } else

    if (*attrName==*xlink_arcrole_attribute_string) {
      *attrValue >> xlinkArcRole;
      ++recognized;
    } else

    if (*attrName==*xlink_title_attribute_string) {
      *attrValue >> xlinkTitle;
      ++recognized;
    } else

    if (*attrName==*xlink_show_attribute_string) {
      *attrValue >> xlinkShow;
      ++recognized;
    } else

    if (*attrName==*xlink_actuate_attribute_string) {
      *attrValue >> xlinkActuate;
      ++recognized;
    } else

    if (*attrName==*xlink_href_attribute_string) {
      *attrValue >> href;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGAnimateTransformElement
    
int
SVGAnimateTransformElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimateTransformElement::parse" << std::endl;
  {

    if (*attrName==*values_attribute_string) {
      *attrValue >> values;
      ++recognized;
    } else

    if (*attrName==*type_attribute_string) {
      *attrValue >> type;
      ++recognized;
    } else

    if (SVGAnimationElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAnimateTransformElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEComponentTransferElement
    
int
SVGFEComponentTransferElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEComponentTransferElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEComponentTransferElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEBlendElement
    
int
SVGFEBlendElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEBlendElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*in2_attribute_string) {
      *attrValue >> in2;
      ++recognized;
    } else

    if (*attrName==*mode_attribute_string) {
      *attrValue >> mode;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEBlendElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEMergeElement
    
int
SVGFEMergeElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEMergeElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEMergeElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTextPositioningElement
    
int
SVGTextPositioningElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTextPositioningElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*dx_attribute_string) {
      *attrValue >> dx;
      ++recognized;
    } else

    if (*attrName==*dy_attribute_string) {
      *attrValue >> dy;
      ++recognized;
    } else

    if (*attrName==*rotate_attribute_string) {
      *attrValue >> rotate;
      ++recognized;
    } else

    if (SVGTextContentElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGEllipseElement
    
int
SVGEllipseElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGEllipseElement::parse" << std::endl;
  {

    if (*attrName==*cx_attribute_string) {
      *attrValue >> cx;
      ++recognized;
    } else

    if (*attrName==*cy_attribute_string) {
      *attrValue >> cy;
      ++recognized;
    } else

    if (*attrName==*rx_attribute_string) {
      *attrValue >> rx;
      ++recognized;
    } else

    if (*attrName==*ry_attribute_string) {
      *attrValue >> ry;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGEllipseElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFilterElement
    
int
SVGFilterElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFilterElement::parse" << std::endl;
  {

    if (*attrName==*filterUnits_attribute_string) {
      *attrValue >> filterUnits;
      ++recognized;
    } else

    if (*attrName==*primitiveUnits_attribute_string) {
      *attrValue >> primitiveUnits;
      ++recognized;
    } else

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFilterElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGClipPathElement
    
int
SVGClipPathElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGClipPathElement::parse" << std::endl;
  {

    if (*attrName==*clipPathUnits_attribute_string) {
      *attrValue >> clipPathUnits;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGClipPathElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGSwitchElement
    
int
SVGSwitchElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGSwitchElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGSwitchElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGMaskElement
    
int
SVGMaskElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGMaskElement::parse" << std::endl;
  {

    if (*attrName==*maskUnits_attribute_string) {
      *attrValue >> maskUnits;
      ++recognized;
    } else

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGMaskElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGViewElement
    
int
SVGViewElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGViewElement::parse" << std::endl;
  {

    if (*attrName==*viewTarget_attribute_string) {
      *attrValue >> viewTarget;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFitToViewBox::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGZoomAndPan::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGViewElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGDefinitionSrcElement
    
int
SVGDefinitionSrcElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGDefinitionSrcElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGDefinitionSrcElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFilterPrimitiveStandardAttributes
    
int
SVGFilterPrimitiveStandardAttributes::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFilterPrimitiveStandardAttributes::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (*attrName==*result_attribute_string) {
      *attrValue >> result;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGFEDistantLightElement
    
int
SVGFEDistantLightElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEDistantLightElement::parse" << std::endl;
  {

    if (*attrName==*azimuth_attribute_string) {
      *attrValue >> azimuth;
      ++recognized;
    } else

    if (*attrName==*elevation_attribute_string) {
      *attrValue >> elevation;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEDistantLightElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEDiffuseLightingElement
    
int
SVGFEDiffuseLightingElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEDiffuseLightingElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*surfaceScale_attribute_string) {
      *attrValue >> surfaceScale;
      ++recognized;
    } else

    if (*attrName==*diffuseConstant_attribute_string) {
      *attrValue >> diffuseConstant;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEDiffuseLightingElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAnimatedPathData
    
int
SVGAnimatedPathData::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimatedPathData::parse" << std::endl;
  {

    if (*attrName==*d_attribute_string) {
      *attrValue >> pathSegList;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGFontFaceSrcElement
    
int
SVGFontFaceSrcElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFontFaceSrcElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFontFaceSrcElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGZoomAndPan
    
int
SVGZoomAndPan::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGZoomAndPan::parse" << std::endl;
  {

    if (*attrName==*zoomAndPan_attribute_string) {
      *attrValue >> zoomAndPan;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGDescElement
    
int
SVGDescElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGDescElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGDescElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGSetElement
    
int
SVGSetElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGSetElement::parse" << std::endl;
  {

    if (SVGAnimationElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGSetElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAnimateElement
    
int
SVGAnimateElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimateElement::parse" << std::endl;
  {

    if (*attrName==*values_attribute_string) {
      *attrValue >> values;
      ++recognized;
    } else

    if (SVGAnimationElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAnimateElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGLangSpace
    
int
SVGLangSpace::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGLangSpace::parse" << std::endl;
  {

    if (*attrName==*xml_lang_attribute_string) {
      *attrValue >> xmllang;
      ++recognized;
    } else

    if (*attrName==*xml_space_attribute_string) {
      *attrValue >> xmlspace;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGGlyphRefElement
    
int
SVGGlyphRefElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGGlyphRefElement::parse" << std::endl;
  {

    if (*attrName==*glyphRef_attribute_string) {
      *attrValue >> glyphRef;
      ++recognized;
    } else

    if (*attrName==*format_attribute_string) {
      *attrValue >> format;
      ++recognized;
    } else

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*dx_attribute_string) {
      *attrValue >> dx;
      ++recognized;
    } else

    if (*attrName==*dy_attribute_string) {
      *attrValue >> dy;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGGlyphRefElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFESpotLightElement
    
int
SVGFESpotLightElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFESpotLightElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*z_attribute_string) {
      *attrValue >> z;
      ++recognized;
    } else

    if (*attrName==*pointsAtX_attribute_string) {
      *attrValue >> pointsAtX;
      ++recognized;
    } else

    if (*attrName==*pointsAtY_attribute_string) {
      *attrValue >> pointsAtY;
      ++recognized;
    } else

    if (*attrName==*pointsAtZ_attribute_string) {
      *attrValue >> pointsAtZ;
      ++recognized;
    } else

    if (*attrName==*specularExponent_attribute_string) {
      *attrValue >> specularExponent;
      ++recognized;
    } else

    if (*attrName==*limitingConeAngle_attribute_string) {
      *attrValue >> limitingConeAngle;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFESpotLightElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAnimationElement
    
int
SVGAnimationElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimationElement::parse" << std::endl;
  {

    if (*attrName==*attributeName_attribute_string) {
      *attrValue >> attributeName;
      ++recognized;
    } else

    if (*attrName==*attributeType_attribute_string) {
      *attrValue >> attributeType;
      ++recognized;
    } else

    if (*attrName==*begin_attribute_string) {
      *attrValue >> begin;
      ++recognized;
    } else

    if (*attrName==*dur_attribute_string) {
      *attrValue >> dur;
      ++recognized;
    } else

    if (*attrName==*end_attribute_string) {
      *attrValue >> end;
      ++recognized;
    } else

    if (*attrName==*min_attribute_string) {
      *attrValue >> min;
      ++recognized;
    } else

    if (*attrName==*max_attribute_string) {
      *attrValue >> max;
      ++recognized;
    } else

    if (*attrName==*restart_attribute_string) {
      *attrValue >> restart;
      ++recognized;
    } else

    if (*attrName==*repeatCount_attribute_string) {
      *attrValue >> repeatCount;
      ++recognized;
    } else

    if (*attrName==*repeatDur_attribute_string) {
      *attrValue >> repeatDur;
      ++recognized;
    } else

    if (*attrName==*fill_attribute_string) {
      *attrValue >> fill;
      ++recognized;
    } else

    if (*attrName==*from_attribute_string) {
      *attrValue >> from;
      ++recognized;
    } else

    if (*attrName==*to_attribute_string) {
      *attrValue >> to;
      ++recognized;
    } else

    if (*attrName==*by_attribute_string) {
      *attrValue >> by;
      ++recognized;
    } else

    if (*attrName==*keyTimes_attribute_string) {
      *attrValue >> keyTimes;
      ++recognized;
    } else

    if (*attrName==*keySplines_attribute_string) {
      *attrValue >> keySplines;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGAltGlyphDefElement
    
int
SVGAltGlyphDefElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAltGlyphDefElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAltGlyphDefElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFETurbulenceElement
    
int
SVGFETurbulenceElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFETurbulenceElement::parse" << std::endl;
  {

    if (*attrName==*numOctaves_attribute_string) {
      *attrValue >> numOctaves;
      ++recognized;
    } else

    if (*attrName==*seed_attribute_string) {
      *attrValue >> seed;
      ++recognized;
    } else

    if (*attrName==*stitchTiles_attribute_string) {
      *attrValue >> stitchTiles;
      ++recognized;
    } else

    if (*attrName==*type_attribute_string) {
      *attrValue >> type;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFETurbulenceElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGComponentTransferFunctionElement
    
int
SVGComponentTransferFunctionElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGComponentTransferFunctionElement::parse" << std::endl;
  {

    if (*attrName==*type_attribute_string) {
      *attrValue >> type;
      ++recognized;
    } else

    if (*attrName==*tableValues_attribute_string) {
      *attrValue >> tableValues;
      ++recognized;
    } else

    if (*attrName==*slope_attribute_string) {
      *attrValue >> slope;
      ++recognized;
    } else

    if (*attrName==*intercept_attribute_string) {
      *attrValue >> intercept;
      ++recognized;
    } else

    if (*attrName==*amplitude_attribute_string) {
      *attrValue >> amplitude;
      ++recognized;
    } else

    if (*attrName==*exponent_attribute_string) {
      *attrValue >> exponent;
      ++recognized;
    } else

    if (*attrName==*offset_attribute_string) {
      *attrValue >> offset;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGMPathElement
    
int
SVGMPathElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGMPathElement::parse" << std::endl;
  {

    if (*attrName==*xlink_href_attribute_string) {
      *attrValue >> href;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGMPathElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGDefsElement
    
int
SVGDefsElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGDefsElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGDefsElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGRectElement
    
int
SVGRectElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGRectElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (*attrName==*rx_attribute_string) {
      *attrValue >> rx;
      ++recognized;
    } else

    if (*attrName==*ry_attribute_string) {
      *attrValue >> ry;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGRectElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGPolylineElement
    
int
SVGPolylineElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGPolylineElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGAnimatedPoints::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGPolylineElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGColorProfileElement
    
int
SVGColorProfileElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGColorProfileElement::parse" << std::endl;
  {

    if (*attrName==*local_attribute_string) {
      *attrValue >> local;
      ++recognized;
    } else

    if (*attrName==*name_attribute_string) {
      *attrValue >> name;
      ++recognized;
    } else

    if (*attrName==*rendering_intent_attribute_string) {
      *attrValue >> renderingIntent;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGColorProfileElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAnimatedPoints
    
int
SVGAnimatedPoints::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimatedPoints::parse" << std::endl;
  {

    if (*attrName==*points_attribute_string) {
      *attrValue >> points;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGCircleElement
    
int
SVGCircleElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGCircleElement::parse" << std::endl;
  {

    if (*attrName==*cx_attribute_string) {
      *attrValue >> cx;
      ++recognized;
    } else

    if (*attrName==*cy_attribute_string) {
      *attrValue >> cy;
      ++recognized;
    } else

    if (*attrName==*r_attribute_string) {
      *attrValue >> r;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGCircleElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTextContentElement
    
int
SVGTextContentElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTextContentElement::parse" << std::endl;
  {

    if (*attrName==*textLength_attribute_string) {
      *attrValue >> textLength;
      ++recognized;
    } else

    if (*attrName==*lengthAdjust_attribute_string) {
      *attrValue >> lengthAdjust;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGUseElement
    
int
SVGUseElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGUseElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGUseElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGMissingGlyphElement
    
int
SVGMissingGlyphElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGMissingGlyphElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGMissingGlyphElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGImageElement
    
int
SVGImageElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGImageElement::parse" << std::endl;
  {

    if (*attrName==*x_attribute_string) {
      *attrValue >> x;
      ++recognized;
    } else

    if (*attrName==*y_attribute_string) {
      *attrValue >> y;
      ++recognized;
    } else

    if (*attrName==*width_attribute_string) {
      *attrValue >> width;
      ++recognized;
    } else

    if (*attrName==*height_attribute_string) {
      *attrValue >> height;
      ++recognized;
    } else

    if (*attrName==*preserveAspectRatio_attribute_string) {
      *attrValue >> preserveAspectRatio;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGImageElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEImageElement
    
int
SVGFEImageElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEImageElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEImageElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTextPathElement
    
int
SVGTextPathElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTextPathElement::parse" << std::endl;
  {

    if (*attrName==*startOffset_attribute_string) {
      *attrValue >> startOffset;
      ++recognized;
    } else

    if (*attrName==*method_attribute_string) {
      *attrValue >> method;
      ++recognized;
    } else

    if (*attrName==*spacing_attribute_string) {
      *attrValue >> spacing;
      ++recognized;
    } else

    if (SVGTextContentElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGTextPathElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEFloodElement
    
int
SVGFEFloodElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEFloodElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*flood_color_attribute_string) {
      *attrValue >> floodColor;
      ++recognized;
    } else

    if (*attrName==*flood_opacity_attribute_string) {
      *attrValue >> floodOpacity;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEFloodElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFontElement
    
int
SVGFontElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFontElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFontElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGRadialGradientElement
    
int
SVGRadialGradientElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGRadialGradientElement::parse" << std::endl;
  {

    if (*attrName==*cx_attribute_string) {
      *attrValue >> cx;
      ++recognized;
    } else

    if (*attrName==*cy_attribute_string) {
      *attrValue >> cy;
      ++recognized;
    } else

    if (*attrName==*r_attribute_string) {
      *attrValue >> r;
      ++recognized;
    } else

    if (*attrName==*fx_attribute_string) {
      *attrValue >> fx;
      ++recognized;
    } else

    if (*attrName==*fy_attribute_string) {
      *attrValue >> fy;
      ++recognized;
    } else

    if (SVGGradientElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGRadialGradientElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGElement
    
int
SVGElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGElement::parse" << std::endl;
  {

    if (*attrName==*id_attribute_string) {
      *attrValue >> id;
      ++recognized;
    } else

    {
    }

  }
  return recognized;
}      

// SVGTitleElement
    
int
SVGTitleElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTitleElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGTitleElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEConvolveMatrixElement
    
int
SVGFEConvolveMatrixElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEConvolveMatrixElement::parse" << std::endl;
  {

    if (*attrName==*kernelMatrix_attribute_string) {
      *attrValue >> kernelMatrix;
      ++recognized;
    } else

    if (*attrName==*divisor_attribute_string) {
      *attrValue >> divisor;
      ++recognized;
    } else

    if (*attrName==*bias_attribute_string) {
      *attrValue >> bias;
      ++recognized;
    } else

    if (*attrName==*targetX_attribute_string) {
      *attrValue >> targetX;
      ++recognized;
    } else

    if (*attrName==*targetY_attribute_string) {
      *attrValue >> targetY;
      ++recognized;
    } else

    if (*attrName==*edgeMode_attribute_string) {
      *attrValue >> edgeMode;
      ++recognized;
    } else

    if (*attrName==*preserveAlpha_attribute_string) {
      *attrValue >> preserveAlpha;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEConvolveMatrixElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEGaussianBlurElement
    
int
SVGFEGaussianBlurElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEGaussianBlurElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (customParseAttributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEGaussianBlurElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGGlyphElement
    
int
SVGGlyphElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGGlyphElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGGlyphElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGGElement
    
int
SVGGElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGGElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTests::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGLangSpace::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGExternalResourcesRequired::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGTransformable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGGElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAnimateColorElement
    
int
SVGAnimateColorElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAnimateColorElement::parse" << std::endl;
  {

    if (*attrName==*values_attribute_string) {
      *attrValue >> values;
      ++recognized;
    } else

    if (SVGAnimationElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAnimateColorElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFEFuncGElement
    
int
SVGFEFuncGElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFEFuncGElement::parse" << std::endl;
  {

    if (SVGComponentTransferFunctionElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFEFuncGElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGAltGlyphItemElement
    
int
SVGAltGlyphItemElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGAltGlyphItemElement::parse" << std::endl;
  {

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGAltGlyphItemElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGFESpecularLightingElement
    
int
SVGFESpecularLightingElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGFESpecularLightingElement::parse" << std::endl;
  {

    if (*attrName==*in_attribute_string) {
      *attrValue >> in1;
      ++recognized;
    } else

    if (*attrName==*surfaceScale_attribute_string) {
      *attrValue >> surfaceScale;
      ++recognized;
    } else

    if (*attrName==*specularConstant_attribute_string) {
      *attrValue >> specularConstant;
      ++recognized;
    } else

    if (*attrName==*specularExponent_attribute_string) {
      *attrValue >> specularExponent;
      ++recognized;
    } else

    if (SVGElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGStylable::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGFilterPrimitiveStandardAttributes::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGFESpecularLightingElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

// SVGTRefElement
    
int
SVGTRefElement::parse_attributes(const String& attrName, const String& attrValue)
{
  int recognized=0;
//  std::cerr << "SVGTRefElement::parse" << std::endl;
  {

    if (SVGTextPositioningElement::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    if (SVGURIReference::parse_attributes(attrName, attrValue)) {
      ++recognized;
    } else

    {
      // std::cerr << "unknown attribute SVGTRefElement::" << attrName << std::endl;
    }

  }
  return recognized;
}      

}
