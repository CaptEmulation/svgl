#ifndef __svg_SVGTextPathElement__
#define __svg_SVGTextPathElement__

// generated by genFromIdl.py
	class xmlostream;
	class BezierPath;

namespace svg {
}

namespace agg {
	class path_storage;
}

namespace svgl {
	class AnimateAdapter;
	class Context;
	class GLInfo;
	class TextInfo;
}

namespace dom {
	class Text;
}

#include <w3c/svg/SVGTextContentElement.hpp>
#include <w3c/svg/SVGURIReference.hpp>
#include <w3c/svg/Attribute.hpp>
#include <w3c/svg/SVGAnimatedLength.hpp>
#include <w3c/svg/String.hpp>

namespace svg {
            extern unicode::String * SVGTextPathElement_element_string;
}

namespace svg {
	class SVGTextPathElement :
		public SVGTextContentElement,
		public SVGURIReference {
	public:

		enum TEXTPATH_METHODTYPE {
			TEXTPATH_METHODTYPE_UNKNOWN = 0,
			TEXTPATH_METHODTYPE_ALIGN = 1,
			TEXTPATH_METHODTYPE_STRETCH = 2
		};


		enum TEXTPATH_SPACINGTYPE {
			TEXTPATH_SPACINGTYPE_UNKNOWN = 0,
			TEXTPATH_SPACINGTYPE_AUTO = 1,
			TEXTPATH_SPACINGTYPE_EXACT = 2
		};

	protected:
		Attribute< SVGAnimatedLength > startOffset;
		Attribute< Animated<TEXTPATH_METHODTYPE> > method;
		Attribute< Animated<TEXTPATH_SPACINGTYPE> > spacing;
	public:
		const Attribute< SVGAnimatedLength >& dom_getStartOffset() const { return startOffset; }

		const Attribute< Animated<TEXTPATH_METHODTYPE> >& dom_getMethod() const { return method; }

		const Attribute< Animated<TEXTPATH_SPACINGTYPE> >& dom_getSpacing() const { return spacing; }

	public:
		const SVGLength & getStartOffset() const { return startOffset.getValue().getAnimatedVal().getValue(); }
		void setStartOffset(const SVGLength& n)  { startOffset.getValue().getAnimatedVal().setValue(n); startOffset.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const TEXTPATH_METHODTYPE & getMethod() const { return method.getValue().getAnimatedVal().getValue(); }
		void setMethod(const TEXTPATH_METHODTYPE& n)  { method.getValue().getAnimatedVal().setValue(n); method.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const TEXTPATH_SPACINGTYPE & getSpacing() const { return spacing.getValue().getAnimatedVal().getValue(); }
		void setSpacing(const TEXTPATH_SPACINGTYPE& n)  { spacing.getValue().getAnimatedVal().setValue(n); spacing.getValue().getBaseVal().setValue(n);  setDamaged(true); }


	public:
	SVGTextPathElement(dom::Document *);
	protected:
		BezierPath* _bezier;
		void buildBezier(svgl::Context*, svgl::GLInfo*, svgl::TextInfo*);

    public:
		virtual void glTextTraverse(svgl::Context*, svgl::GLInfo*, svgl::TextInfo*) ;
		virtual void glTextTraversePCDATA(svgl::Context*, svgl::GLInfo*, svgl::TextInfo*, dom::Text*) ;


	  virtual void getBoundingBox(svgl::Context* svglContext, svgl::GLInfo* glinfo, float*, float*, float*, float*) ;
	  //virtual void glTraverseFill(svgl::Context* svglContext, svgl::GLInfo* glinfo) ;
	  //virtual void glTraverseStroke(svgl::Context* svglContext, svgl::GLInfo* glinfo, float sw) ;
          virtual void glTraverseBoundingBox(svgl::Context * svglContext, svgl::GLInfo* glinfo) ;
          virtual void asBezier(svgl::Context* svglContext, svgl::GLInfo* glinfo, BezierPath*);
          virtual void asBezier(svgl::Context* svglContext, svgl::GLInfo* glinfo, agg::path_storage*);

	  virtual void glTraverseFill(svgl::Context* svglContext, svgl::GLInfo* glinfo);
	  virtual void glTraverseStroke(svgl::Context* svglContext, svgl::GLInfo* glinfo, float sw);
	public:
		virtual int parse_attributes(const String&, const String&);
		virtual void print_attributes(xmlostream&);
	public:
		virtual svgl::AnimateAdapter* getAttributeByName(const String&);

	public:
		virtual ~SVGTextPathElement();
		virtual const String getDtdElement() const { return SVGTextPathElement_element_string; }
	};
}


#endif // __svg_SVGTextPathElement__
