// generated by makeParseAttribute.py

#include <w3c/svg/makeEnumType.hpp>
#include <svgl/parseHelper.hpp>
//#include <dom/DOM.hpp>
#include <w3c/svg/String.hpp>
#include <svgl/AnimateAdapter.hpp>
#include <svgl/AnimateAdapterDouble.hpp>
#include <svgl/AnimateAdapterColor.hpp>
#include <w3c/svg/String.hpp>
#include <w3c/svg/SVGAElement.hpp>
#include <w3c/svg/SVGElement.hpp>
#include <w3c/svg/SVGURIReference.hpp>
#include <w3c/svg/SVGTests.hpp>
#include <w3c/svg/SVGLangSpace.hpp>
#include <w3c/svg/SVGExternalResourcesRequired.hpp>
#include <w3c/svg/SVGStylable.hpp>
#include <w3c/svg/SVGTransformable.hpp>
#include <w3c/svg/SVGAltGlyphDefElement.hpp>
#include <w3c/svg/SVGAltGlyphElement.hpp>
#include <w3c/svg/SVGTextPositioningElement.hpp>
#include <w3c/svg/SVGTextContentElement.hpp>
#include <w3c/svg/SVGAltGlyphItemElement.hpp>
#include <w3c/svg/SVGAnimateColorElement.hpp>
#include <w3c/svg/SVGAnimationElement.hpp>
#include <w3c/svg/SVGAnimateElement.hpp>
#include <w3c/svg/SVGAnimateMotionElement.hpp>
#include <w3c/svg/SVGAnimateTransformElement.hpp>
#include <w3c/svg/SVGAnimatedPathData.hpp>
#include <w3c/svg/SVGAnimatedPoints.hpp>
#include <w3c/svg/SVGCircleElement.hpp>
#include <w3c/svg/SVGClipPathElement.hpp>
#include <w3c/svg/SVGColorProfileElement.hpp>
#include <w3c/svg/SVGComponentTransferFunctionElement.hpp>
#include <w3c/svg/SVGCursorElement.hpp>
#include <w3c/svg/SVGDefinitionSrcElement.hpp>
#include <w3c/svg/SVGDefsElement.hpp>
#include <w3c/svg/SVGDescElement.hpp>
#include <w3c/svg/SVGEllipseElement.hpp>
#include <w3c/svg/SVGFEBlendElement.hpp>
#include <w3c/svg/SVGFilterPrimitiveStandardAttributes.hpp>
#include <w3c/svg/SVGFEColorMatrixElement.hpp>
#include <w3c/svg/SVGFEComponentTransferElement.hpp>
#include <w3c/svg/SVGFECompositeElement.hpp>
#include <w3c/svg/SVGFEConvolveMatrixElement.hpp>
#include <w3c/svg/SVGFEDiffuseLightingElement.hpp>
#include <w3c/svg/SVGFEDisplacementMapElement.hpp>
#include <w3c/svg/SVGFEDistantLightElement.hpp>
#include <w3c/svg/SVGFEFloodElement.hpp>
#include <w3c/svg/SVGFEFuncAElement.hpp>
#include <w3c/svg/SVGFEFuncBElement.hpp>
#include <w3c/svg/SVGFEFuncGElement.hpp>
#include <w3c/svg/SVGFEFuncRElement.hpp>
#include <w3c/svg/SVGFEGaussianBlurElement.hpp>
#include <w3c/svg/SVGFEImageElement.hpp>
#include <w3c/svg/SVGFEMergeElement.hpp>
#include <w3c/svg/SVGFEMergeNodeElement.hpp>
#include <w3c/svg/SVGFEMorphologyElement.hpp>
#include <w3c/svg/SVGFEOffsetElement.hpp>
#include <w3c/svg/SVGFEPointLightElement.hpp>
#include <w3c/svg/SVGFESpecularLightingElement.hpp>
#include <w3c/svg/SVGFESpotLightElement.hpp>
#include <w3c/svg/SVGFETileElement.hpp>
#include <w3c/svg/SVGFETurbulenceElement.hpp>
#include <w3c/svg/SVGFilterElement.hpp>
#include <w3c/svg/SVGFitToViewBox.hpp>
#include <w3c/svg/SVGFontElement.hpp>
#include <w3c/svg/SVGFontFaceElement.hpp>
#include <w3c/svg/SVGFontFaceFormatElement.hpp>
#include <w3c/svg/SVGFontFaceNameElement.hpp>
#include <w3c/svg/SVGFontFaceSrcElement.hpp>
#include <w3c/svg/SVGFontFaceUriElement.hpp>
#include <w3c/svg/SVGForeignObjectElement.hpp>
#include <w3c/svg/SVGGElement.hpp>
#include <w3c/svg/SVGGlyphElement.hpp>
#include <w3c/svg/SVGGlyphRefElement.hpp>
#include <w3c/svg/SVGGradientElement.hpp>
#include <w3c/svg/SVGHKernElement.hpp>
#include <w3c/svg/SVGImageElement.hpp>
#include <w3c/svg/SVGLineElement.hpp>
#include <w3c/svg/SVGLinearGradientElement.hpp>
#include <w3c/svg/SVGMPathElement.hpp>
#include <w3c/svg/SVGMarkerElement.hpp>
#include <w3c/svg/SVGMaskElement.hpp>
#include <w3c/svg/SVGMetadataElement.hpp>
#include <w3c/svg/SVGMissingGlyphElement.hpp>
#include <w3c/svg/SVGPathElement.hpp>
#include <w3c/svg/SVGPatternElement.hpp>
#include <w3c/svg/SVGPolygonElement.hpp>
#include <w3c/svg/SVGPolylineElement.hpp>
#include <w3c/svg/SVGRadialGradientElement.hpp>
#include <w3c/svg/SVGRectElement.hpp>
#include <w3c/svg/SVGSVGElement.hpp>
#include <w3c/svg/SVGZoomAndPan.hpp>
#include <w3c/svg/SVGScriptElement.hpp>
#include <w3c/svg/SVGSetElement.hpp>
#include <w3c/svg/SVGStopElement.hpp>
#include <w3c/svg/SVGStyleElement.hpp>
#include <w3c/svg/SVGSwitchElement.hpp>
#include <w3c/svg/SVGSymbolElement.hpp>
#include <w3c/svg/SVGTRefElement.hpp>
#include <w3c/svg/SVGTSpanElement.hpp>
#include <w3c/svg/SVGTextElement.hpp>
#include <w3c/svg/SVGTextPathElement.hpp>
#include <w3c/svg/SVGTitleElement.hpp>
#include <w3c/svg/SVGUseElement.hpp>
#include <w3c/svg/SVGVKernElement.hpp>
#include <w3c/svg/SVGViewElement.hpp>
#include <w3c/svg/SVGViewSpec.hpp>


namespace svg {

// SVGAnimateMotionElement
    
svgl::AnimateAdapter*
SVGAnimateMotionElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimateMotionElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*values_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGLengthList > >(&values);
    } else

    if (*attrName==*path_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGPathSegList > >(&path);
    } else

    if (*attrName==*rotate_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&rotate);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGAnimationElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAnimateMotionElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFontFaceUriElement
    
svgl::AnimateAdapter*
SVGFontFaceUriElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFontFaceUriElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFontFaceUriElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFontFaceElement
    
svgl::AnimateAdapter*
SVGFontFaceElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFontFaceElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFontFaceElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEFuncBElement
    
svgl::AnimateAdapter*
SVGFEFuncBElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEFuncBElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGComponentTransferFunctionElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEFuncBElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEFuncAElement
    
svgl::AnimateAdapter*
SVGFEFuncAElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEFuncAElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGComponentTransferFunctionElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEFuncAElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEFuncRElement
    
svgl::AnimateAdapter*
SVGFEFuncRElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEFuncRElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGComponentTransferFunctionElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEFuncRElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGForeignObjectElement
    
svgl::AnimateAdapter*
SVGForeignObjectElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGForeignObjectElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGForeignObjectElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEMorphologyElement
    
svgl::AnimateAdapter*
SVGFEMorphologyElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEMorphologyElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*operator_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_MORPHOLOGY_OPERATOR> > >(&operator_);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEMorphologyElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGMarkerElement
    
svgl::AnimateAdapter*
SVGMarkerElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGMarkerElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*refX_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&refX);
    } else

    if (*attrName==*refY_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&refY);
    } else

    if (*attrName==*markerUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_MARKERUNITS> > >(&markerUnits);
    } else

    if (*attrName==*markerWidth_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&markerWidth);
    } else

    if (*attrName==*markerHeight_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&markerHeight);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFitToViewBox::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGMarkerElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFETileElement
    
svgl::AnimateAdapter*
SVGFETileElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFETileElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFETileElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGPathElement
    
svgl::AnimateAdapter*
SVGPathElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGPathElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*pathLength_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&pathLength);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGAnimatedPathData::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGPathElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTSpanElement
    
svgl::AnimateAdapter*
SVGTSpanElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTSpanElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGTextPositioningElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGTSpanElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEColorMatrixElement
    
svgl::AnimateAdapter*
SVGFEColorMatrixElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEColorMatrixElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_FECOLORMATRIX_TYPE> > >(&type);
    } else

    if (*attrName==*values_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumberList > >(&values);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEColorMatrixElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFontFaceFormatElement
    
svgl::AnimateAdapter*
SVGFontFaceFormatElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFontFaceFormatElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFontFaceFormatElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEOffsetElement
    
svgl::AnimateAdapter*
SVGFEOffsetElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEOffsetElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*dx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&dx);
    } else

    if (*attrName==*dy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&dy);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEOffsetElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGSymbolElement
    
svgl::AnimateAdapter*
SVGSymbolElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGSymbolElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFitToViewBox::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGSymbolElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEMergeNodeElement
    
svgl::AnimateAdapter*
SVGFEMergeNodeElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEMergeNodeElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEMergeNodeElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTransformable
    
svgl::AnimateAdapter*
SVGTransformable::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTransformable::getAttributeByName " << attrName << std::endl;


    if (*attrName==*transform_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedTransformList > >(&transform);
    } else

  return 0;
}

// SVGStyleElement
    
svgl::AnimateAdapter*
SVGStyleElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGStyleElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*xml_space_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&xmlspace);
    } else

    if (*attrName==*type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&type);
    } else

    if (*attrName==*media_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&media);
    } else

    if (*attrName==*title_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&title);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGStyleElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGPolygonElement
    
svgl::AnimateAdapter*
SVGPolygonElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGPolygonElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGAnimatedPoints::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGPolygonElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGCursorElement
    
svgl::AnimateAdapter*
SVGCursorElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGCursorElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGCursorElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFECompositeElement
    
svgl::AnimateAdapter*
SVGFECompositeElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFECompositeElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*in2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in2);
    } else

    if (*attrName==*operator_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_FECOMPOSITE_OPERATOR> > >(&operator_);
    } else

    if (*attrName==*k1_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&k1);
    } else

    if (*attrName==*k2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&k2);
    } else

    if (*attrName==*k3_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&k3);
    } else

    if (*attrName==*k4_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&k4);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFECompositeElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGGradientElement
    
svgl::AnimateAdapter*
SVGGradientElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGGradientElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*gradientUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_UNIT_TYPE> > >(&gradientUnits);
    } else

    if (*attrName==*gradientTransform_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedTransformList > >(&gradientTransform);
    } else

    if (*attrName==*spreadMethod_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_SPREADMETHOD> > >(&spreadMethod);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

  }

  return 0;
}

// SVGLinearGradientElement
    
svgl::AnimateAdapter*
SVGLinearGradientElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGLinearGradientElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x1_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x1);
    } else

    if (*attrName==*y1_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y1);
    } else

    if (*attrName==*x2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x2);
    } else

    if (*attrName==*y2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y2);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGGradientElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGLinearGradientElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTextElement
    
svgl::AnimateAdapter*
SVGTextElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTextElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGTextContentElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGTextElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEPointLightElement
    
svgl::AnimateAdapter*
SVGFEPointLightElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEPointLightElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&y);
    } else

    if (*attrName==*z_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&z);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEPointLightElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGHKernElement
    
svgl::AnimateAdapter*
SVGHKernElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGHKernElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGHKernElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGStopElement
    
svgl::AnimateAdapter*
SVGStopElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGStopElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*offset_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&offset);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGStopElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEDisplacementMapElement
    
svgl::AnimateAdapter*
SVGFEDisplacementMapElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEDisplacementMapElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*in2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in2);
    } else

    if (*attrName==*scale_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&scale);
    } else

    if (*attrName==*xChannelSelector_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_CHANNEL> > >(&xChannelSelector);
    } else

    if (*attrName==*yChannelSelector_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_CHANNEL> > >(&yChannelSelector);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEDisplacementMapElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGLineElement
    
svgl::AnimateAdapter*
SVGLineElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGLineElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x1_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x1);
    } else

    if (*attrName==*y1_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y1);
    } else

    if (*attrName==*x2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x2);
    } else

    if (*attrName==*y2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y2);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGLineElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFontFaceNameElement
    
svgl::AnimateAdapter*
SVGFontFaceNameElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFontFaceNameElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFontFaceNameElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGPatternElement
    
svgl::AnimateAdapter*
SVGPatternElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGPatternElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*patternUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_UNIT_TYPE> > >(&patternUnits);
    } else

    if (*attrName==*patternTransform_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedTransformList > >(&patternTransform);
    } else

    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFitToViewBox::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGPatternElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGExternalResourcesRequired
    
svgl::AnimateAdapter*
SVGExternalResourcesRequired::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGExternalResourcesRequired::getAttributeByName " << attrName << std::endl;


    if (*attrName==*externalResourcesRequired_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedBoolean > >(&externalResourcesRequired);
    } else

  return 0;
}

// SVGScriptElement
    
svgl::AnimateAdapter*
SVGScriptElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGScriptElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&type);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGScriptElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGStylable
    
svgl::AnimateAdapter*
SVGStylable::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGStylable::getAttributeByName " << attrName << std::endl;


    if (*attrName==*class_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&className);
    } else

    if (*attrName==*style_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< css::CSSStyleDeclaration > >(&style);
    } else

  return 0;
}

// SVGFitToViewBox
    
svgl::AnimateAdapter*
SVGFitToViewBox::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFitToViewBox::getAttributeByName " << attrName << std::endl;


    if (*attrName==*viewBox_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedRect > >(&viewBox);
    } else

    if (*attrName==*preserveAspectRatio_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedPreserveAspectRatio > >(&preserveAspectRatio);
    } else

  return 0;
}

// SVGTests
    
svgl::AnimateAdapter*
SVGTests::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTests::getAttributeByName " << attrName << std::endl;


    if (*attrName==*requiredFeatures_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGStringList > >(&requiredFeatures);
    } else

    if (*attrName==*requiredExtensions_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGStringList > >(&requiredExtensions);
    } else

    if (*attrName==*systemLanguage_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGStringList > >(&systemLanguage);
    } else

  return 0;
}

// SVGSVGElement
    
svgl::AnimateAdapter*
SVGSVGElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGSVGElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    if (*attrName==*contentScriptType_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&contentScriptType);
    } else

    if (*attrName==*contentStyleType_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&contentStyleType);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFitToViewBox::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGZoomAndPan::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGSVGElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGViewSpec
    
svgl::AnimateAdapter*
SVGViewSpec::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGViewSpec::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGZoomAndPan::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFitToViewBox::getAttributeByName(attrName);
       if (res) {
         return res;
       }

  }

  return 0;
}

// SVGVKernElement
    
svgl::AnimateAdapter*
SVGVKernElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGVKernElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGVKernElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGMetadataElement
    
svgl::AnimateAdapter*
SVGMetadataElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGMetadataElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGMetadataElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAElement
    
svgl::AnimateAdapter*
SVGAElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*target_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&target);
    } else

    if (*attrName==*xlink_show_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_XLINK_SHOW > >(&xlinkShow);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAltGlyphElement
    
svgl::AnimateAdapter*
SVGAltGlyphElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAltGlyphElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*glyphRef_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&glyphRef);
    } else

    if (*attrName==*format_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&format);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGTextPositioningElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAltGlyphElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGURIReference
    
svgl::AnimateAdapter*
SVGURIReference::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGURIReference::getAttributeByName " << attrName << std::endl;


    if (*attrName==*xlink_type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_XLINK_TYPE > >(&xlinkType);
    } else

    if (*attrName==*xlink_role_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&xlinkRole);
    } else

    if (*attrName==*xlink_arcrole_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&xlinkArcRole);
    } else

    if (*attrName==*xlink_title_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&xlinkTitle);
    } else

    if (*attrName==*xlink_show_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_XLINK_SHOW > >(&xlinkShow);
    } else

    if (*attrName==*xlink_actuate_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_XLINK_ACTUATE > >(&xlinkActuate);
    } else

    if (*attrName==*xlink_href_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&href);
    } else

  return 0;
}

// SVGAnimateTransformElement
    
svgl::AnimateAdapter*
SVGAnimateTransformElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimateTransformElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*values_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&values);
    } else

    if (*attrName==*type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_ANIMATETRANSFORM_TYPE > >(&type);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGAnimationElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAnimateTransformElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEComponentTransferElement
    
svgl::AnimateAdapter*
SVGFEComponentTransferElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEComponentTransferElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEComponentTransferElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEBlendElement
    
svgl::AnimateAdapter*
SVGFEBlendElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEBlendElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*in2_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in2);
    } else

    if (*attrName==*mode_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_FEBLEND_MODE> > >(&mode);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEBlendElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEMergeElement
    
svgl::AnimateAdapter*
SVGFEMergeElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEMergeElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEMergeElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTextPositioningElement
    
svgl::AnimateAdapter*
SVGTextPositioningElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTextPositioningElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLengthList > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLengthList > >(&y);
    } else

    if (*attrName==*dx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLengthList > >(&dx);
    } else

    if (*attrName==*dy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLengthList > >(&dy);
    } else

    if (*attrName==*rotate_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumberList > >(&rotate);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGTextContentElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

  }

  return 0;
}

// SVGEllipseElement
    
svgl::AnimateAdapter*
SVGEllipseElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGEllipseElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*cx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&cx);
    } else

    if (*attrName==*cy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&cy);
    } else

    if (*attrName==*rx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&rx);
    } else

    if (*attrName==*ry_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&ry);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGEllipseElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFilterElement
    
svgl::AnimateAdapter*
SVGFilterElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFilterElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*filterUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_UNIT_TYPE> > >(&filterUnits);
    } else

    if (*attrName==*primitiveUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_UNIT_TYPE> > >(&primitiveUnits);
    } else

    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFilterElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGClipPathElement
    
svgl::AnimateAdapter*
SVGClipPathElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGClipPathElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*clipPathUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_UNIT_TYPE> > >(&clipPathUnits);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGClipPathElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGSwitchElement
    
svgl::AnimateAdapter*
SVGSwitchElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGSwitchElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGSwitchElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGMaskElement
    
svgl::AnimateAdapter*
SVGMaskElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGMaskElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*maskUnits_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_UNIT_TYPE> > >(&maskUnits);
    } else

    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGMaskElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGViewElement
    
svgl::AnimateAdapter*
SVGViewElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGViewElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*viewTarget_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGElement* > >(&viewTarget);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFitToViewBox::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGZoomAndPan::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGViewElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGDefinitionSrcElement
    
svgl::AnimateAdapter*
SVGDefinitionSrcElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGDefinitionSrcElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGDefinitionSrcElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFilterPrimitiveStandardAttributes
    
svgl::AnimateAdapter*
SVGFilterPrimitiveStandardAttributes::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFilterPrimitiveStandardAttributes::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    if (*attrName==*result_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&result);
    } else

  return 0;
}

// SVGFEDistantLightElement
    
svgl::AnimateAdapter*
SVGFEDistantLightElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEDistantLightElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*azimuth_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&azimuth);
    } else

    if (*attrName==*elevation_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&elevation);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEDistantLightElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEDiffuseLightingElement
    
svgl::AnimateAdapter*
SVGFEDiffuseLightingElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEDiffuseLightingElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*surfaceScale_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&surfaceScale);
    } else

    if (*attrName==*diffuseConstant_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&diffuseConstant);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEDiffuseLightingElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAnimatedPathData
    
svgl::AnimateAdapter*
SVGAnimatedPathData::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimatedPathData::getAttributeByName " << attrName << std::endl;


    if (*attrName==*d_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGPathSegList > >(&pathSegList);
    } else

  return 0;
}

// SVGFontFaceSrcElement
    
svgl::AnimateAdapter*
SVGFontFaceSrcElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFontFaceSrcElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFontFaceSrcElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGZoomAndPan
    
svgl::AnimateAdapter*
SVGZoomAndPan::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGZoomAndPan::getAttributeByName " << attrName << std::endl;


    if (*attrName==*zoomAndPan_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_ZOOMANDPAN > >(&zoomAndPan);
    } else

  return 0;
}

// SVGDescElement
    
svgl::AnimateAdapter*
SVGDescElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGDescElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGDescElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGSetElement
    
svgl::AnimateAdapter*
SVGSetElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGSetElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGAnimationElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGSetElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAnimateElement
    
svgl::AnimateAdapter*
SVGAnimateElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimateElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*values_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGLengthList > >(&values);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGAnimationElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAnimateElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGLangSpace
    
svgl::AnimateAdapter*
SVGLangSpace::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGLangSpace::getAttributeByName " << attrName << std::endl;


    if (*attrName==*xml_lang_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&xmllang);
    } else

    if (*attrName==*xml_space_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_XML_SPACE > >(&xmlspace);
    } else

  return 0;
}

// SVGGlyphRefElement
    
svgl::AnimateAdapter*
SVGGlyphRefElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGGlyphRefElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*glyphRef_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&glyphRef);
    } else

    if (*attrName==*format_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&format);
    } else

    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< float > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< float > >(&y);
    } else

    if (*attrName==*dx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< float > >(&dx);
    } else

    if (*attrName==*dy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< float > >(&dy);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGGlyphRefElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFESpotLightElement
    
svgl::AnimateAdapter*
SVGFESpotLightElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFESpotLightElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&y);
    } else

    if (*attrName==*z_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&z);
    } else

    if (*attrName==*pointsAtX_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&pointsAtX);
    } else

    if (*attrName==*pointsAtY_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&pointsAtY);
    } else

    if (*attrName==*pointsAtZ_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&pointsAtZ);
    } else

    if (*attrName==*specularExponent_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&specularExponent);
    } else

    if (*attrName==*limitingConeAngle_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&limitingConeAngle);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFESpotLightElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAnimationElement
    
svgl::AnimateAdapter*
SVGAnimationElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimationElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*attributeName_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&attributeName);
    } else

    if (*attrName==*attributeType_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_ANIMATION_ATTRIBUTE_TYPE > >(&attributeType);
    } else

    if (*attrName==*begin_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&begin);
    } else

    if (*attrName==*dur_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&dur);
    } else

    if (*attrName==*end_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&end);
    } else

    if (*attrName==*min_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&min);
    } else

    if (*attrName==*max_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&max);
    } else

    if (*attrName==*restart_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_ANIMATION_RESTART > >(&restart);
    } else

    if (*attrName==*repeatCount_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&repeatCount);
    } else

    if (*attrName==*repeatDur_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&repeatDur);
    } else

    if (*attrName==*fill_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVG_ANIMATION_FILL > >(&fill);
    } else

    if (*attrName==*from_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&from);
    } else

    if (*attrName==*to_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&to);
    } else

    if (*attrName==*by_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&by);
    } else

    if (*attrName==*keyTimes_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGNumberList > >(&keyTimes);
    } else

    if (*attrName==*keySplines_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGNumberList > >(&keySplines);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

  }

  return 0;
}

// SVGAltGlyphDefElement
    
svgl::AnimateAdapter*
SVGAltGlyphDefElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAltGlyphDefElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAltGlyphDefElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFETurbulenceElement
    
svgl::AnimateAdapter*
SVGFETurbulenceElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFETurbulenceElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*numOctaves_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedInteger > >(&numOctaves);
    } else

    if (*attrName==*seed_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&seed);
    } else

    if (*attrName==*stitchTiles_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_STITCHTYPE> > >(&stitchTiles);
    } else

    if (*attrName==*type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_TURBULENCE_TYPE> > >(&type);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFETurbulenceElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGComponentTransferFunctionElement
    
svgl::AnimateAdapter*
SVGComponentTransferFunctionElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGComponentTransferFunctionElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*type_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_FECOMPONENTTRANSFER_TYPE> > >(&type);
    } else

    if (*attrName==*tableValues_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumberList > >(&tableValues);
    } else

    if (*attrName==*slope_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&slope);
    } else

    if (*attrName==*intercept_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&intercept);
    } else

    if (*attrName==*amplitude_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&amplitude);
    } else

    if (*attrName==*exponent_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&exponent);
    } else

    if (*attrName==*offset_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&offset);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

  }

  return 0;
}

// SVGMPathElement
    
svgl::AnimateAdapter*
SVGMPathElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGMPathElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*xlink_href_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&href);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGMPathElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGDefsElement
    
svgl::AnimateAdapter*
SVGDefsElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGDefsElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGDefsElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGRectElement
    
svgl::AnimateAdapter*
SVGRectElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGRectElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    if (*attrName==*rx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&rx);
    } else

    if (*attrName==*ry_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&ry);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGRectElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGPolylineElement
    
svgl::AnimateAdapter*
SVGPolylineElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGPolylineElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGAnimatedPoints::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGPolylineElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGColorProfileElement
    
svgl::AnimateAdapter*
SVGColorProfileElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGColorProfileElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*local_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&local);
    } else

    if (*attrName==*name_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&name);
    } else

    if (*attrName==*rendering_intent_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< RENDERING_INTENT > >(&renderingIntent);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGColorProfileElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAnimatedPoints
    
svgl::AnimateAdapter*
SVGAnimatedPoints::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimatedPoints::getAttributeByName " << attrName << std::endl;


    if (*attrName==*points_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGPointList > >(&points);
    } else

  return 0;
}

// SVGCircleElement
    
svgl::AnimateAdapter*
SVGCircleElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGCircleElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*cx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&cx);
    } else

    if (*attrName==*cy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&cy);
    } else

    if (*attrName==*r_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&r);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGCircleElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTextContentElement
    
svgl::AnimateAdapter*
SVGTextContentElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTextContentElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*textLength_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&textLength);
    } else

    if (*attrName==*lengthAdjust_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<LENGTHADJUST> > >(&lengthAdjust);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

  }

  return 0;
}

// SVGUseElement
    
svgl::AnimateAdapter*
SVGUseElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGUseElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGUseElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGMissingGlyphElement
    
svgl::AnimateAdapter*
SVGMissingGlyphElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGMissingGlyphElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGMissingGlyphElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGImageElement
    
svgl::AnimateAdapter*
SVGImageElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGImageElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*x_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&x);
    } else

    if (*attrName==*y_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&y);
    } else

    if (*attrName==*width_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&width);
    } else

    if (*attrName==*height_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&height);
    } else

    if (*attrName==*preserveAspectRatio_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedPreserveAspectRatio > >(&preserveAspectRatio);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGImageElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEImageElement
    
svgl::AnimateAdapter*
SVGFEImageElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEImageElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEImageElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTextPathElement
    
svgl::AnimateAdapter*
SVGTextPathElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTextPathElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*startOffset_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&startOffset);
    } else

    if (*attrName==*method_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<TEXTPATH_METHODTYPE> > >(&method);
    } else

    if (*attrName==*spacing_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<TEXTPATH_SPACINGTYPE> > >(&spacing);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGTextContentElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGTextPathElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEFloodElement
    
svgl::AnimateAdapter*
SVGFEFloodElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEFloodElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*flood_color_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&floodColor);
    } else

    if (*attrName==*flood_opacity_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&floodOpacity);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEFloodElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFontElement
    
svgl::AnimateAdapter*
SVGFontElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFontElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFontElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGRadialGradientElement
    
svgl::AnimateAdapter*
SVGRadialGradientElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGRadialGradientElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*cx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&cx);
    } else

    if (*attrName==*cy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&cy);
    } else

    if (*attrName==*r_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&r);
    } else

    if (*attrName==*fx_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&fx);
    } else

    if (*attrName==*fy_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedLength > >(&fy);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGGradientElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGRadialGradientElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGElement
    
svgl::AnimateAdapter*
SVGElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*id_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&id);
    } else

  return 0;
}

// SVGTitleElement
    
svgl::AnimateAdapter*
SVGTitleElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTitleElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGTitleElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEConvolveMatrixElement
    
svgl::AnimateAdapter*
SVGFEConvolveMatrixElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEConvolveMatrixElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*kernelMatrix_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumberList > >(&kernelMatrix);
    } else

    if (*attrName==*divisor_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&divisor);
    } else

    if (*attrName==*bias_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&bias);
    } else

    if (*attrName==*targetX_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedInteger > >(&targetX);
    } else

    if (*attrName==*targetY_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedInteger > >(&targetY);
    } else

    if (*attrName==*edgeMode_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< Animated<SVG_EDGEMODE> > >(&edgeMode);
    } else

    if (*attrName==*preserveAlpha_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedBoolean > >(&preserveAlpha);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEConvolveMatrixElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEGaussianBlurElement
    
svgl::AnimateAdapter*
SVGFEGaussianBlurElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEGaussianBlurElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEGaussianBlurElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGGlyphElement
    
svgl::AnimateAdapter*
SVGGlyphElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGGlyphElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGGlyphElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGGElement
    
svgl::AnimateAdapter*
SVGGElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGGElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTests::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGLangSpace::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGExternalResourcesRequired::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGTransformable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGGElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAnimateColorElement
    
svgl::AnimateAdapter*
SVGAnimateColorElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAnimateColorElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*values_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< DOMString > >(&values);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGAnimationElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAnimateColorElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFEFuncGElement
    
svgl::AnimateAdapter*
SVGFEFuncGElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFEFuncGElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGComponentTransferFunctionElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFEFuncGElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGAltGlyphItemElement
    
svgl::AnimateAdapter*
SVGAltGlyphItemElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGAltGlyphItemElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGAltGlyphItemElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGFESpecularLightingElement
    
svgl::AnimateAdapter*
SVGFESpecularLightingElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGFESpecularLightingElement::getAttributeByName " << attrName << std::endl;


    if (*attrName==*in_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedString > >(&in1);
    } else

    if (*attrName==*surfaceScale_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&surfaceScale);
    } else

    if (*attrName==*specularConstant_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&specularConstant);
    } else

    if (*attrName==*specularExponent_attribute_string) {
      return new svgl::AnimateAdapterTemplate< Attribute< SVGAnimatedNumber > >(&specularExponent);
    } else

    {
       svgl::AnimateAdapter* res = 0;

       res = SVGElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGStylable::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGFilterPrimitiveStandardAttributes::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGFESpecularLightingElement::" << attrName << std::endl;
      }

  }

  return 0;
}

// SVGTRefElement
    
svgl::AnimateAdapter*
SVGTRefElement::getAttributeByName(const String& attrName)
{
//  std::cerr << "SVGTRefElement::getAttributeByName " << attrName << std::endl;


    {
       svgl::AnimateAdapter* res = 0;

       res = SVGTextPositioningElement::getAttributeByName(attrName);
       if (res) {
         return res;
       }

       res = SVGURIReference::getAttributeByName(attrName);
       if (res) {
         return res;
       }

      {
         std::cerr << "unknown attribute SVGTRefElement::" << attrName << std::endl;
      }

  }

  return 0;
}

}
