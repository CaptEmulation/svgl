#ifndef __svg_SVGStylable__
#define __svg_SVGStylable__

// generated by genFromIdl.py
	class xmlostream;
	class BezierPath;
	class glPoly;

namespace dom {
	class Document;
}

namespace agg {
	class path_storage;
}

namespace svg {
	class SVGClipPathElement;
	class SVGFilterElement;
	class SVGMarkerElement;
	class SVGPatternElement;
	class SVGGradientElement;
	class SVGElement;
}

namespace svgl {
	class AnimateAdapter;
	class Context;
	class GLInfo;
	class ExternalEntityManager;
}

namespace css {
	class CSSValue;
	class Color;
}

#include <w3c/svg/Attribute.hpp>
#include <w3c/svg/SVGAnimatedString.hpp>
#include <w3c/css/CSSStyleDeclaration.hpp>
#include <w3c/svg/DOMString.hpp>
#include <w3c/svg/String.hpp>

namespace svg {
	class SVGStylable {
	public:
	protected:
		Attribute< SVGAnimatedString > className;
		Attribute< css::CSSStyleDeclaration > style;
	public:
		const Attribute< SVGAnimatedString >& dom_getClassName() const { return className; }

		const Attribute< css::CSSStyleDeclaration >& dom_getStyle() const { return style; }

	public:
		const SVGString & getClassName() const { return className.getValue().getAnimatedVal().getValue(); }
		void setClassName(const SVGString& n)  { className.getValue().getAnimatedVal().setValue(n); className.getValue().getBaseVal().setValue(n); }

		const css::CSSStyleDeclaration & getStyle() const { return style.getValue(); }
		void setStyle(const css::CSSStyleDeclaration& n)  { style.setValue(n); }


		Attribute< css::CSSStyleDeclaration >& getStyle() { return style; }
		SVGClipPathElement* getSVGClipPathElement(svgl::ExternalEntityManager *, dom::Document *);
		SVGFilterElement* getSVGFilterElement(svgl::ExternalEntityManager *, dom::Document *);
		SVGMarkerElement* getSVGMarkerElement(svgl::ExternalEntityManager *, dom::Document *);
		SVGMarkerElement* getSVGMarkerStartElement(svgl::ExternalEntityManager *, dom::Document *);
		SVGMarkerElement* getSVGMarkerEndElement(svgl::ExternalEntityManager *, dom::Document *);
		SVGMarkerElement* getSVGMarkerMidElement(svgl::ExternalEntityManager *, dom::Document *);


		void glTraverseMarker(svgl::Context* svglContext, svgl::GLInfo* glinfo, float shapeStrokeWidth);
		void glTraverse(svgl::Context* svglContext, svgl::GLInfo* glinfo, bool stencilStrokeHint, bool traverseEvenIfNonVisible);

	virtual void computeGeometry(svgl::Context * svglContext, svgl::GLInfo* glinfo);
	virtual void computeGeometryForDrawing(svgl::Context * svglContext, svgl::GLInfo* glinfo);

private:
	  void glTraverseOpacity(svgl::Context * svglContext,
		 svgl::GLInfo* glinfo,
		 const css::Color * fill,
		 const css::Color * stroke,
		 float fillOpacity,
		 float strokeOpacity,
		 float opacity,
		 float strokeWidth,
                 bool stencilStrokeHint
				 );

	glPoly * fillGlPoly, * strokeGlPoly;

	  friend class SVGElement;
	  virtual void updateChildrenStyle();
                                 
public:

		virtual ~SVGStylable() {}

#define ATTRDEF(type, name, dtdstr)				   virtual css::CSSStyle::type get##name() const;		   bool isMy##name() const; /* if specified for this element */	   void unsetMy##name();					   svg::SVGElement * getElementDefining##name() const;		   void set##name(css::CSSStyle::type);
#include <w3c/css/inherited_style_defs.hpp>
#include <w3c/css/not_inherited_style_defs.hpp> //mmm not sure...
#undef ATTRDEF

#define ATTRDEF(type, name, dtdstr)				  void set##name(float r, float g, float b); 	  void set##name(const char*); // "red"
	  //void setFill(URL);
ATTRDEF(const_PaintType,Color,"color")
ATTRDEF(const_PaintType,Fill,"fill")
ATTRDEF(const_PaintType,Stroke,"stroke")
ATTRDEF(const_PaintType,StopColor,"stop-color")
#undef ATTRDEF

#define ATTRDEF(type, name, dtdstr)				  void set##name(svg::SVGGradientElement*);		  void set##name(svg::SVGPatternElement*);
ATTRDEF(const_PaintType,Color,"color")
ATTRDEF(const_PaintType,Fill,"fill")
ATTRDEF(const_PaintType,Stroke,"stroke")
#undef ATTRDEF


		 void pickTraverse(svgl::Context*, svgl::GLInfo*)  ;

	  virtual void getBoundingBox(svgl::Context* svglContext, svgl::GLInfo* glinfo, float*, float*, float*, float*) ;
	  //virtual void glTraverseFill(svgl::Context* svglContext, svgl::GLInfo* glinfo) ;
	  //virtual void glTraverseStroke(svgl::Context* svglContext, svgl::GLInfo* glinfo, float sw) ;
          virtual void glTraverseBoundingBox(svgl::Context * svglContext, svgl::GLInfo* glinfo) ;
          virtual void asBezier(svgl::Context* svglContext, svgl::GLInfo* glinfo, BezierPath*);
          virtual void asBezier(svgl::Context* svglContext, svgl::GLInfo* glinfo, agg::path_storage*);

	  virtual void glTraverseFill(svgl::Context* svglContext, svgl::GLInfo* glinfo);
	  virtual void glTraverseStroke(svgl::Context* svglContext, svgl::GLInfo* glinfo, float sw);

  int customParseAttributes(const String& attrName, const String& attrValue);
	public:
		virtual css::CSSValue* getPresentationAttribute ( const DOMString& name ) ;
		virtual int parse_attributes(const String&, const String&);
		virtual void print_attributes(xmlostream&);
	public:
		virtual svgl::AnimateAdapter* getAttributeByName(const String&);
	};
}


#endif // __svg_SVGStylable__
