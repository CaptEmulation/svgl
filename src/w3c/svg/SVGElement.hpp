#ifndef __svg_SVGElement__
#define __svg_SVGElement__

// generated by genFromIdl.py
	class xmlostream;
	class DOM_Node;

namespace svg {
	class SVGSVGElement;
	class SVGElement;
	class SVGStylable;
}

namespace svgl {
	class AnimateAdapter;
	class Context;
	class GLInfo;
	class AnimationInfo;
	class TextureSnapshot;
}

#include <w3c/svg/Element.hpp>
#include <w3c/svg/Attribute.hpp>
#include <w3c/svg/DOMString.hpp>
#include <w3c/svg/String.hpp>
#include <vector>
#include <svgl/SimpleShapeTraversal.hpp>

namespace svg {
	class SVGElement :
		public Element {
	public:
	protected:
		Attribute< DOMString > id;
		Attribute< SVGSVGElement* > ownerSVGElement;
		Attribute< SVGElement* > viewportElement;
	public:
		const Attribute< DOMString >& dom_getId() const { return id; }
		Attribute< DOMString >& dom_getId() { return id; }
		void dom_setId(const DOMString& n)  { id.setValue(n); }

		const Attribute< SVGSVGElement* >& dom_getOwnerSVGElement() const { return ownerSVGElement; }

		const Attribute< SVGElement* >& dom_getViewportElement() const { return viewportElement; }

	public:
		const DOMString & getId() const { return id.getValue(); }
		DOMString & getId() { return id.getValue(); }
		void setId(const DOMString& n)  { id.setValue(n);  setDamaged(true); }

		const SVGSVGElement* getOwnerSVGElement() const { return ownerSVGElement.getValue(); }
		void setOwnerSVGElement(SVGSVGElement* n)  { ownerSVGElement.setValue(n);  setDamaged(true); }

		const SVGElement* getViewportElement() const { return viewportElement.getValue(); }
		void setViewportElement(SVGElement* n)  { viewportElement.setValue(n);  setDamaged(true); }


   public:
      virtual const String getDtdElement() const=0;
      virtual void setOwnerAndViewPort(SVGSVGElement* owner, SVGElement* viewport);
      virtual void print(xmlostream&);
      virtual void updateStyle(SVGStylable* parent);
      virtual void glTraverseChildren(svgl::Context*, svgl::GLInfo*);
      virtual void pickTraverseChildren(svgl::Context*, svgl::GLInfo*);
      virtual void glTraverseBoundingBoxChildren(svgl::Context*, svgl::GLInfo*);
      virtual void animationTraverseChildren(svgl::AnimationInfo*);
      void getPercentageWidthHeight(svgl::GLInfo*, float *percentage_width, float *percentage_height);
      SVGElement(dom::Document* doc, unicode::String* tag);
      ~SVGElement();
      typedef std::vector<svg::SVGElement*> Branch;
      virtual void glTraverseBranch(svgl::Context*, svgl::GLInfo*, Branch::iterator& beg, Branch::iterator& end);

      virtual dom::Node * insertBefore(dom::Node * newChild, dom::Node * refChild) throw(dom::DOMException);
      virtual void raise();
      virtual void lower();
      virtual void above(SVGElement*) throw(dom::DOMException);
      virtual void below(SVGElement*) throw(dom::DOMException);

	void setId(const char*);
	const char *getIdcc();


	virtual dom::Node *	internalInsertBefore(dom::Node * newChild, dom::Node * refChild) throw(dom::DOMException);
	virtual dom::Node *	removeChild(dom::Node * oldChild) throw(dom::DOMException);
	virtual dom::Node *	internalRemoveChild(dom::Node * oldChild) throw(dom::DOMException);
	virtual dom::Node *	replaceChild(dom::Node * newChild, dom::Node * oldChild) throw(dom::DOMException);

	// compilation stuff

	void setDamaged(bool);
	bool getDamaged() const;
	void setStyleDamaged(bool);
	void compile(bool);
	void compileAsATexture(bool yesno);

	virtual bool areChildrenDamaged();
        virtual void damageChildren();

	virtual void registerUse(svgl::Context*);

      protected:
          bool _askForCompileGlTraverse;
	  unsigned int _glList;
	  bool _inGlList;
	bool _damaged;
	svgl::TextureSnapshot *_snap;
	bool _compileAsATexture;
	  virtual bool glCompiled();
	  bool preManageGlCompilation();
	  void postManageGlCompilation();

	  bool _childrenDamaged;
	  bool _aChildIsNotDamagedAnymore;
	  void setChildrenDamaged(bool);
	  void setAChildIsNotDamagedAnymore();
	  bool _canBeCompiled;
	  virtual bool canBeCompiled();
	  void setCanBeCompiled(bool);
	  void setGlCompiled(bool);

	  template <class SimpleShape> friend void svgl::glTraverseSimpleShape(SimpleShape * shape, svgl::Context * svglContext, svgl::GLInfo* glinfo);
	  template <class SimpleShape> friend void svgl::pickTraverseSimpleShape(SimpleShape * shape, svgl::Context * svglContext, svgl::GLInfo* glinfo);
	  template <class SimpleShape> friend void svgl::glTraverseBoundingBoxSimpleShape(SimpleShape * shape, svgl::Context * svglContext, svgl::GLInfo* glinfo);

      public:



		virtual void glTraverse(svgl::Context*, svgl::GLInfo*)  ;

		virtual void glTraverseBoundingBox(svgl::Context*, svgl::GLInfo*)  ;

		virtual void pickTraverse(svgl::Context*, svgl::GLInfo*)  ;

	public:
		virtual void animationTraverse(svgl::AnimationInfo*)  ;
	public:
		virtual int parse_attributes(const String&, const String&);
		virtual void print_attributes(xmlostream&);
	public:
		virtual svgl::AnimateAdapter* getAttributeByName(const String&);
	};
}


#endif // __svg_SVGElement__
