#ifndef __svg_SVGGradientElement__
#define __svg_SVGGradientElement__

// generated by genFromIdl.py
	class xmlostream;

namespace svg {
}

namespace svgl {
	class AnimateAdapter;
}

#include <w3c/svg/SVGElement.hpp>
#include <w3c/svg/SVGURIReference.hpp>
#include <w3c/svg/SVGExternalResourcesRequired.hpp>
#include <w3c/svg/SVGStylable.hpp>
#include <w3c/svg/SVGUnitTypes.hpp>
#include <w3c/svg/Attribute.hpp>
#include <w3c/svg/SVGAnimatedTransformList.hpp>
#include <w3c/svg/String.hpp>
#include <svgl/StopElements.hpp>

namespace svg {
	class SVGGradientElement :
		public SVGElement,
		public SVGURIReference,
		public SVGExternalResourcesRequired,
		public SVGStylable,
		public SVGUnitTypes {
	public:

		enum SVG_SPREADMETHOD {
			SVG_SPREADMETHOD_UNKNOWN = 0,
			SVG_SPREADMETHOD_PAD = 1,
			SVG_SPREADMETHOD_REFLECT = 2,
			SVG_SPREADMETHOD_REPEAT = 3
		};

	protected:
		Attribute< Animated<SVG_UNIT_TYPE> > gradientUnits;
		Attribute< SVGAnimatedTransformList > gradientTransform;
		Attribute< Animated<SVG_SPREADMETHOD> > spreadMethod;
	public:
		const Attribute< Animated<SVG_UNIT_TYPE> >& dom_getGradientUnits() const { return gradientUnits; }

		const Attribute< SVGAnimatedTransformList >& dom_getGradientTransform() const { return gradientTransform; }

		const Attribute< Animated<SVG_SPREADMETHOD> >& dom_getSpreadMethod() const { return spreadMethod; }

	public:
		const SVG_UNIT_TYPE & getGradientUnits() const { return gradientUnits.getValue().getAnimatedVal().getValue(); }
		void setGradientUnits(const SVG_UNIT_TYPE& n)  { gradientUnits.getValue().getAnimatedVal().setValue(n); gradientUnits.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const SVGTransformList & getGradientTransform() const { return gradientTransform.getValue().getAnimatedVal().getValue(); }
		void setGradientTransform(const SVGTransformList& n)  { gradientTransform.getValue().getAnimatedVal().setValue(n); gradientTransform.getValue().getBaseVal().setValue(n);  setDamaged(true); }

		const SVG_SPREADMETHOD & getSpreadMethod() const { return spreadMethod.getValue().getAnimatedVal().getValue(); }
		void setSpreadMethod(const SVG_SPREADMETHOD& n)  { spreadMethod.getValue().getAnimatedVal().setValue(n); spreadMethod.getValue().getBaseVal().setValue(n);  setDamaged(true); }


		SVGGradientElement(dom::Document *, unicode::String *);
		virtual void glPreTraverse(svgl::Context*, svgl::GLInfo* glinfo) = 0;
		virtual void glPostTraverse(svgl::Context*, svgl::GLInfo* glinfo, float x, float y, float width, float height) = 0;
		void getStopElements(svgl::StopElements*);
	public:
		virtual int parse_attributes(const String&, const String&);
		virtual void print_attributes(xmlostream&);
	public:
		virtual svgl::AnimateAdapter* getAttributeByName(const String&);

	public:
		virtual ~SVGGradientElement();
	};
}


#endif // __svg_SVGGradientElement__
