<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"
	"http://www.w3.org/TR/REC-html40/strict.dtd"
[ <!ENTITY % svgl "SvGl"> ]
>

<html lang="en">

<head>
<title>
SVGL Documentation
</title>
<link rel="stylesheet" type="text/css" href="svgldoc.css">
</head>

<body>
<h1>SVGL Documentation</h1>

<h2>copyright</h2>
(C) Ecole des Mines de Nantes, 2000-2001. All rights reserved.

<h2>abstract</h2>
svgl is a toolkit that displays <a href="http://www.w3.org/Graphics/SVG/Overview.htm8">svg</a>
documents using the <a href="http://www.opengl.org">OpenGL</a> library.
This document describes the internals of the toolkit.

<h2>table of content</h2>

<ol>
<li>Introduction
<li>Code organisation
   <ol>
   <li>Directory structure
   <li>Python scripts
   <li>Class hierarchy overview
   </ol>
<li>Display strategies
<li>Picking strategy
<li>Status
   <ol>
   <li>Working features
   <li>Bugs
   <li>Plans
   </ol>
</ol>

<h2>introduction</h2>

<h2>code organization</h2>
<h3>Directory Structure</h3>

just after unpacking the distribution:
<samp>
$ls
Makefile  README  contrib/  docs/  examples/  include/	misc/  scripts/  share/  src/  tools/
$
</samp>

<ul>
<li><samp>contrib</samp>: contributions (glutSVGViewer and svg2raster)
<li><samp>docs/</samp>: documentation
<li><samp>examples/</samp>: some svg files to test the lib
<li><samp>include/</samp>: headers for dom, css, svgl (a helper lib), smil and GL additions
<li><samp>misc/</samp>: old stuff or tries, but not currently in use
<li><samp>scripts/</samp>: python scripts to generate some code from the idl and the dtd
<li><samp>share/</samp>: idl, dtd and colors definition
<li><samp>src/</samp>: non-generated sources
<li><samp>tools/</samp>: tools required to build the lib (currently only <samp>depcomp(1)</samp>)
</ul>

after a bluid:
<ul>
<li><samp>gen/</samp>: sources (<samp>gen/src/</samp>) and headers (<samp>gen/svg/</samp>) generated by python scripts
<li><samp>fonts/</samp>: truetype fonts
</ul>

after a run:
<ul>
<li><samp>font_cache/</samp>: vector and pixmap based fonts generated at run-time by svgl
</ul>

<h2>display strategies</h2>

<h2>picking strategies</h2>

<h3>simple picking</h3>
<p>
Simple picking is the process of picking every objects in a small
square around the cursor position. &svgl; uses OpenGL selection
to implement picking. Basically, the pick manager has
a <code>pick</code> method that returns a pair of iterators (of type <code>PickManager::HitIterator</code>)
on selection stacks. The first one is the first hit stack that has been returned when an OpenGL drawing
has hit the selection area (begin). The second one is the one-after-the-last
stack (end). Dereferencing a <code>PickManager::HitIterator (operator*)</code> returns another pair
of iterator (of type <code>PickManager::HitElementIterator)</code> which gives
the beginning and the end of the stack.
</p>

<p>
The stack in itself is a container of svg::SVGElement* that are pushed
on the stack during the picking process. What one generally wants is the path
followed by the traversal that eventually reached the basic drawing element
that hits the selections area, ie something like this:
</p>

<p>
<![CDATA[
<svg><g><use><use><symbol><g><rect>
]]></p>

<p>
with any combinations of these elements.
</p>

<p>
The problem is that in selection mode, the stencil test is not used. It means
that we have to detect if a shape that hits the selection area
is visible or not. The method consists in detecting when a clipping path
is drawn, testing if this clipping path actually hits the selection area,
testing for a regular shape if it's clipped, and finally testing if the clip
path corresponding to this shape has hit the selection area.
</p>

<p>
When drawing a clipped shape, we have this order of operations:
<ol>
<li>the clip path is <code>glPreTraversed</code>
<li>its children are <code>glTraversed</code>
<li>the shape is rendered
<li>the clip path is <code>glPostTraversed</code> to pop the stencil
<li>its children are <code>glTraversed</code>
</ol>
</p>

<p>
This means that there is a hit each time a child of the clip path is
traversed. As a user of a pick detection, we don't want to handle
this kind of hit. It should be ignored where iterating from
stack to stack.
</p>

<p>
In order to know if the clip path has hit the selection area (which means
that the clipped shape is visible in this area), we test if in a hit
stack we find 0 (the special value that specifiates a <code>svg::SVGClipPathElement</code> is
traversed), and if in the stack we can find some other <code>svg::SVGElement</code>
after the 0, which means that one of the shape of the clip path
has hit, and hence the clip path is valid...
</p>

<h4>Known bugs</h4>

Currently picking does not work with complex clip trees:

<ul>
<li>a clip path that is used by multiple unrelated shapes (and hence multiple unrelated transforms)
<li>a clip path that contains clipped shapes
</ul>

<h2>Status</h2>
<a href="../TODO">TODO</a>


</body>
</html>