import string

import parse_attr
import parse_dtd
#import cppName
import cppHeader
from make_cpp_string_name import *
import config
import GenFile

translate_to_classname = {
    "Tspan": "TSpan",
    "Tref": "TRef",
    "Mpath": "MPath",
    "Svg": "SVG",
    "Vkern": "VKern",
    "Hkern": "HKern"
    }

def make_cppname(name):
    beg=0
    while 1:
        pos = string.find(name, '-', beg)
        if pos==-1:
            pos = string.find(name, '-', beg)
        if pos>0:
            res = name[:pos]+ string.upper(name[pos+1]) + name[pos+2:]
            name=res
            beg=pos
        else:
            break

    if name[:2]=="Fe":
        name = "FE" + name[2:]
    else:
        try:
            tmp=translate_to_classname[name]
            name = tmp
        except KeyError:
            pass
    return name


all_headers=[]

#if len(parse_dtd.entity_type_decls):
#	for name, entity_type in parse_dtd.entity_type_decls.items():
#            pass

all_elements = []




def titi(elements, class_suffix='Element'):
    if len(elements)==0:
        return
    for name, entity_types in elements.items():
        # name = cppName.make_cppname(name+class_suffix)
        # header = cppHeader.Header(name, prefix='svg')
        # name = make_cppname(name+class_suffix)
        all_elements.append(name)


def toto(entity_common_attrs, class_suffix=''):
	if len(entity_common_attrs)==0:
		return
	for name, entity_types in entity_common_attrs.items():
		name = cppName.make_cppname(name+class_suffix)
		header = cppHeader.Header(name, prefix='svg')
		# print name
		output = '''
namespace svg {
	struct %s '''%(name)

		inherits=''
		includes=''
		fields=''
		#print entity_types
		for entity_type in entity_types:

			if str(entity_type.__class__) == 'parse_attr.attr_entity_ref':
				entity_name = cppName.make_cppname(entity_type.entity_name)
				inherits = inherits +'\t\t\t%s,\n'%(entity_name)
				includes = includes +'#include <w3c/svg/%s.hpp>\n'%(entity_name)

			elif isinstance(entity_type, parse_attr.attr_named_entity_ref):
				entity_name = cppName.make_cppname(entity_type.entity_name)
				includes = includes + '#include <w3c/svg/%s.hpp>\n'%(entity_name)
				fields = fields + '\t\t\t%s %s;\n'%(entity_name, cppName.make_cppname(entity_type.name))

			elif isinstance(entity_type, parse_attr.attr_named_enum):
				entity_name = cppName.make_cppname(entity_type.name)
				enumstr = '''
			enum %sEnum {
'''%(entity_name)
				for i in entity_type.enums:
					enumstr = enumstr + '\t\t\t\t%s,\n'%(entity_name+'_'+cppName.make_cppname(i))
				enumstr = enumstr + '\t\t\t};\n\n'
				enumstr = enumstr + '\t\t\t%sEnum %s;\n'%(entity_name, entity_name)
				fields=fields+enumstr+'\n'
				

		if len(inherits):
			inherits=':\n' + inherits[:-2]

		output = '// generated by genSvgElement.py\n\n' + includes + output + inherits + ' {\n\n' + fields
		output = output + '''
	};
}
'''
		header.add_content(output)
		header.dump('svg')
		all_headers.append(name)

# toto(parse_dtd.entity_common_attrs)
titi(parse_dtd.attlists, class_suffix='Element')

includes=''
includes = includes + '''#include <svgl/getNextSVGElement.hpp>
#include <w3c/svg/strings.hpp>

'''

output = '''
svg::SVGElement*
svg::getNextSVGElement(const DOM_Node& n, DOM_Node & next, SVGSVGElement *owner, SVGElement *viewport)
{
   DOM_Node node=n;

   while (node!=0 && (node.getNodeType() ==  DOM_Node::COMMENT_NODE ) )
      node = node.getNextSibling();
   next = node;
   if (node==0) {
      return 0;
   }

   DOMString   nodeName = node.getNodeName();

   if(node.getNodeType() ==  DOM_Node::TEXT_NODE) {
     svg::SVGPCDATAElement *elem = new svg::SVGPCDATAElement;
     elem->content = node.getNodeValue();
     return elem;
   } else
'''

strdef_output=''

for element_dtd_name in all_elements:
#    if element=='mpath':
#        continue
    classname = string.upper(element_dtd_name[0])+element_dtd_name[1:]
    classname = make_cppname(classname)
    #name=classname
    element_cpp_name = make_cpp_string_name(element_dtd_name)
    includes = includes + '#include <w3c/svg/SVG%sElement.hpp>\n'%(classname)
    
    output = output + '''
   if (nodeName==svg::%s_element_string) {
      svg::SVG%sElement *elem = new svg::SVG%sElement;
      elem->parse(node, owner, viewport);
      return elem;
   } else
'''%(element_cpp_name, classname, classname)

    strdef_output = strdef_output + 'STRDEF(%s,"%s")\n'%(classname, element_dtd_name)

output = output +'''
   {
      std::cerr << "element " << nodeName.c_str() << " (type " << node.getNodeType() << ") unknown" << std::endl;
      return 0;
   }
}
'''

#f = open(config.genDir+"/getNextSVGElement.cpp", 'w')
#f.write('// generated by genSvgElement.py\n\n' + includes +'\n'+output)

f= GenFile.gfopen(config.genDir+"/strings_def.hpp", 'w')
f.write('// generated by genSvgElement.py\n\n' + strdef_output)

header = cppHeader.Header("svg", prefix='svg')
header.add_content('// generated by genSvgElement.py\n\n' + includes)
header.dump(path=config.genDir)
